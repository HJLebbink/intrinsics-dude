;hand crafted ====================================================================
;
GENERAL	MOV	Move	MOV.html

GENERAL	CMOVA	Move if above (CF=0 and ZF=0) (CMOVA=CMOVNBE)	CMOVcc.html
GENERAL	CMOVAE	Move if above or equal (CF=0) (CMOVAE=CMOVNB=CMOVNC)	CMOVcc.html
GENERAL	CMOVB	Move if below (CF=1) (CMOVB=CMOVC=CMOVNAE)	CMOVcc.html
GENERAL	CMOVBE	Move if below or equal (CF=1 or ZF=1) (CMOVBE=CMOVNA)	CMOVcc.html
GENERAL	CMOVE	Move if equal (ZF=1) (CMOVE=CMOVZ)	CMOVcc.html
GENERAL	CMOVG	Move if greater (ZF=0 and SF=OF) (CMOVG=CMOVNLE)	CMOVcc.html
GENERAL	CMOVGE	Move if greater or equal (SF=OF) (CMOVGE=CMOVNL)	CMOVcc.html
GENERAL	CMOVL	Move if less (SF!=OF) (CMOVL=CMOVNGE)	CMOVcc.html
GENERAL	CMOVLE	Move if less or equal (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)	CMOVcc.html
GENERAL	CMOVNA	Move if not above (CF=1 or ZF=1) (CMOVBE=CMOVNA)	CMOVcc.html
GENERAL	CMOVNAE	Move if not above or equal (CF=1) (CMOVB=CMOVC=CMOVNAE)	CMOVcc.html
GENERAL	CMOVNB	Move if not below (CF=0) (CMOVAE=CMOVNB=CMOVNC)	CMOVcc.html
GENERAL	CMOVNBE	Move if not below or equal (CF=0 and ZF=0) (CMOVA=CMOVNBE)	CMOVcc.html
GENERAL	CMOVNC	Move if not carry (CF=0) (CMOVAE=CMOVNB=CMOVNC)	CMOVcc.html
GENERAL	CMOVNE	Move if not equal (ZF=0) (CMOVNE=CMOVNZ)	CMOVcc.html
GENERAL	CMOVNG	Move if not greater (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)	CMOVcc.html
GENERAL	CMOVNGE	Move if not greater or equal (SF!=OF) (CMOVL=CMOVNGE)	CMOVcc.html
GENERAL	CMOVNL	Move if not less (SF=OF) (CMOVGE=CMOVNL)	CMOVcc.html
GENERAL	CMOVNLE	Move if not less or equal (ZF=0 and SF=OF) (CMOVG=CMOVNLE)	CMOVcc.html
GENERAL	CMOVNO	Move if not overflow (OF=0)	CMOVcc.html
GENERAL	CMOVNP	Move if not parity (PF=0) (CMOVNP=CMOVPO)	CMOVcc.html
GENERAL	CMOVNS	Move if not sign (SF=0)	CMOVcc.html
GENERAL	CMOVNZ	Move if not zero (ZF=0 CMOVNE=CMOVNZ)	CMOVcc.html
GENERAL	CMOVO	Move if overflow (OF=1)	CMOVcc.html
GENERAL	CMOVP	Move if parity (PF=1) (CMOVP=CMOVPE)	CMOVcc.html
GENERAL	CMOVPE	Move if parity even (PF=1) (CMOVP=CMOVPE)	CMOVcc.html
GENERAL	CMOVPO	Move if parity odd (PF=0) (CMOVNP=CMOVPO)	CMOVcc.html
GENERAL	CMOVS	Move if sign (SF=1)	CMOVcc.html
GENERAL	CMOVZ	Move if zero (ZF=1) (CMOVE=CMOVZ)	CMOVcc.html
;====================================================================
GENERAL	CQO	Convert Quadword to OWord	CWD_CDQ_CQO.html
GENERAL	CWD	Convert Word to Doubleword	CWD_CDQ_CQO.html
GENERAL	CDQ	Convert Doubleword to Quadword	CWD_CDQ_CQO.html
;====================================================================
GENERAL	JA	Jump if above (CF=0 and ZF=0) (JA=JNBE)	Jcc.html
GENERAL	JAE	Jump if above or equal (CF=0) (JAE=JNB)	Jcc.html
GENERAL	JB	Jump if below (CF=1) (JB=JNAE)	Jcc.html
GENERAL	JBE	Jump if below or equal (CF=1 or ZF=1) (JBE=JNA)	Jcc.html
GENERAL	JC	Jump if carry (CF=1)	Jcc.html
GENERAL	JE	Jump if equal (ZF=1) (JE=JZ)	Jcc.html
GENERAL	JG	Jump if greater (ZF=0 and SF=OF) (JG=JNLE)	Jcc.html
GENERAL	JGE	Jump if greater or equal (SF=OF) (JGE=JNL)	Jcc.html
GENERAL	JL	Jump if less (SF!=OF) (JL=JNGE)	Jcc.html
GENERAL	JLE	Jump if less or equal (ZF=1 or SF!=OF) (JLE=JNG)	Jcc.html
GENERAL	JNA	Jump if not above (CF=1 or ZF=1) (JBE=JNA)	Jcc.html
GENERAL	JNAE	Jump if not above or equal (CF=1) (JB=JNAE)	Jcc.html
GENERAL	JNB	Jump if not below (CF=0) (JAE=JNB)	Jcc.html
GENERAL	JNBE	Jump if not below or equal (CF=0 and ZF=0) (JA=JNBE)	Jcc.html
GENERAL	JNC	Jump if not carry (CF=0)	Jcc.html
GENERAL	JNE	Jump if not equal (ZF=0) (JNE=JNZ)	Jcc.html
GENERAL	JNG	Jump if not greater (ZF=1 or SF!=OF) (JLE=JNG)	Jcc.html
GENERAL	JNGE	Jump if not greater or equal (SF!=OF) (JL=JNGE)	Jcc.html
GENERAL	JNL	Jump if not less (SF=OF) (JGE=JNL)	Jcc.html
GENERAL	JNLE	Jump if not less or equal (ZF=0 and SF=OF) (JG=JNLE)	Jcc.html
GENERAL	JNO	Jump if not overflow (OF=0)	Jcc.html
GENERAL	JNP	Jump if not parity (PF=0) (JNP=JPO)	Jcc.html
GENERAL	JNS	Jump if not sign (SF=0)	Jcc.html
GENERAL	JNZ	Jump if not zero (ZF=0) (JNE=JNZ)	Jcc.html
GENERAL	JO	Jump if overflow (OF=1)	Jcc.html
GENERAL	JP	Jump if parity (PF=1) (JP=JPE)	Jcc.html
GENERAL	JPE	Jump if parity even (PF=1) (JP=JPE)	Jcc.html
GENERAL	JPO	Jump if parity odd (PF=0) (JNP=JPO)	Jcc.html
GENERAL	JS	Jump if sign (SF=1)	Jcc.html
GENERAL	JZ	Jump if zero (ZF=1) (JE=JZ)	Jcc.html

GENERAL	JMP	Unconditional Jump	JMP.html
;====================================================================

GENERAL	RCR	Rotate Carry Left	RCL_RCR_ROL_ROR.html
GENERAL	RCL	Rotate Carry Right	RCL_RCR_ROL_ROR.html
GENERAL	ROR	Rotate Right	RCL_RCR_ROL_ROR.html
GENERAL	ROL	Rotate Left	RCL_RCR_ROL_ROR.html
GENERAL	SAR	Shift Arithmetic Right	SAL_SAR_SHL_SHR.html
GENERAL	SHL	Shift Logical Left	SAL_SAR_SHL_SHR.html
GENERAL	SHR	Shift Logical Right	SAL_SAR_SHL_SHR.html
GENERAL	SAL	Shift Arithmetic Left	SAL_SAR_SHL_SHR.html
GENERAL	SARX	Shift Arithmetic Right Without Affecting Flags	SARX_SHLX_SHRX.html
GENERAL	SHLX	Shift Logical Left Without Affecting Flags	SARX_SHLX_SHRX.html
GENERAL	SHRX	Shift Logical Right Without Affecting Flags	SARX_SHLX_SHRX.html
;====================================================================
GENERAL	SETA	Set byte if above (CF=0 and ZF=0) (SETA=SETNBE)	SETcc.html
GENERAL	SETAE	Set byte if above or equal (CF=0) (SETAE=SETNC=SETNB)	SETcc.html
GENERAL	SETB	Set byte if below (CF=1) (SETB=SETC=SETNAE)	SETcc.html
GENERAL	SETBE	Set byte if below or equal (CF=1 or ZF=1) (SETBE=SETNA)	SETcc.html
GENERAL	SETC	Set byte if carry (CF=1 SETB=SETC=SETNAE)	SETcc.html
GENERAL	SETE	Set byte if equal (ZF=1) (SETE=SETZ)	SETcc.html
GENERAL	SETG	Set byte if greater (ZF=0 and SF=OF) (SETG=SETNLE)	SETcc.html
GENERAL	SETGE	Set byte if greater or equal (SF=OF) (SETGE=SETNL)	SETcc.html
GENERAL	SETL	Set byte if less (SF!=OF) (SETL=SETNGE)	SETcc.html
GENERAL	SETLE	Set byte if less or equal (ZF=1 or SF!=OF) (SETLE=SETNG)	SETcc.html
GENERAL	SETNA	Set byte if not above (CF=1 or ZF=1) (SETBE=SETNA)	SETcc.html
GENERAL	SETNAE	Set byte if not above or equal (CF=1) (SETB=SETC=SETNAE)	SETcc.html
GENERAL	SETNB	Set byte if not below (CF=0) (SETAE=SETNC=SETNB)	SETcc.html
GENERAL	SETNBE	Set byte if not below or equal (CF=0 and ZF=0) (SETA=SETNBE)	SETcc.html
GENERAL	SETNC	Set byte if not carry (CF=0) (SETAE=SETNC=SETNB)	SETcc.html
GENERAL	SETNE	Set byte if not equal (ZF=0) (SETNE=SETNZ)	SETcc.html
GENERAL	SETNG	Set byte if not greater (ZF=1 or SF!=OF) (SETLE=SETNG)	SETcc.html
GENERAL	SETNGE	Set byte if not greater or equal (SF!=OF) (SETL=SETNGE)	SETcc.html
GENERAL	SETNL	Set byte if not less (SF=OF) (SETGE=SETNL)	SETcc.html
GENERAL	SETNLE	Set byte if not less or equal (ZF=0 and SF=OF) (SETG=SETNLE)	SETcc.html
GENERAL	SETNO	Set byte if not overflow (OF=0)	SETcc.html
GENERAL	SETNP	Set byte if not parity (PF=0) (SETNP=SETPO)	SETcc.html
GENERAL	SETNS	Set byte if not sign (SF=0)	SETcc.html
GENERAL	SETNZ	Set byte if not zero (ZF=0) (SETNE=SETNZ)	SETcc.html
GENERAL	SETO	Set byte if overflow (OF=1)	SETcc.html
GENERAL	SETP	Set byte if parity (PF=1) (SETP=SETPE)	SETcc.html
GENERAL	SETPE	Set byte if parity even (PF=1) (SETP=SETPE)	SETcc.html
GENERAL	SETPO	Set byte if parity odd (PF=0 SETNP=SETPO)	SETcc.html
GENERAL	SETS	Set byte if sign (SF=1)	SETcc.html
GENERAL	SETZ	Set byte if zero (ZF=1) (SETE=SETZ)	SETcc.html
;CYRIX EMMX ====================================================================
GENERAL	PADDSIW	Packed Add with Saturation	
GENERAL	PSUBSIW	Packed Subtract with Saturation	
GENERAL	PAVEB	Packed Average	
GENERAL	PDISTIB	Packed Distance and Accumulate	
GENERAL	PMACHRIW	Packed Multiply and Accumulate with Rounding	
GENERAL	PMAGW	Packed Magnitude	
GENERAL	PMULHRIW	Packed Multiply High with Rounding using implied destination	
GENERAL	PMVZB	Packed Conditional Move (zero)	
GENERAL	PMVNZB	Packed Conditional Move (not zero)	
GENERAL	PMVLZB	Packed Conditional Move (less than zero)	
GENERAL	PMVGEZB	Packed Conditional Move (greater than or equal to zero)	
GENERAL	PMULHRWC	Packed Multiply High with Rounding	
GENERAL	RDSHR	Packed Multiply High with Rounding	
;
PADDSIW	MM,MM/MEM	CYRIX	PADDSIW MM,MM/MEM	Packed Add with Saturation.
PSUBSIW	MM,MM/MEM	CYRIX	PSUBSIW MM,MM/MEM	Packed Subtract with Saturation.
PAVEB	MM,MM/MEM	CYRIX	PAVEB MM,MM/MEM	Packed Average.
PDISTIB	MM,MEM	CYRIX	PDISTIB MM,MEM	Packed Distance and Accumulate.
PMACHRIW	MM,MEM	CYRIX	PMACHRIW MM,MEM	Packed Multiply and Accumulate with Rounding.
PMAGW	MM,MM/MEM	CYRIX	PMAGW MM,MM/MEM	Packed Magnitude.
PMULHRIW	MM,MM/MEM	CYRIX	PMULHRIW MM, MM/MEM	Multiply High with Rounding using implied destination.
PMVZB	MM,MEM	CYRIX	PMVZB MM,MEM	Packed Conditional Move (zero).
PMVNZB	MM,MEM	CYRIX	PMVNZB MM,MEM	Packed Conditional Move (not zero).
PMVLZB	MM,MEM	CYRIX	PMVLZB MM,MEM	Packed Conditional Move (less than zero).
PMVGEZB	MM,MEM	CYRIX	PMVGEZB MM,MEM	Packed Conditional Move (greater than or equal to zero).
PMULHRWC	MM,MM/MEM	CYRIX	PMULHRWC MM, MM/MEM	Packed Multiply High with Rounding.
XSTORE		CYRIX	XSTORE	TODO
XCRYPTECB		CYRIX	XCRYPTECB	TODO
XCRYPTCBC		CYRIX	XCRYPTCBC	TODO
XCRYPTCTR		CYRIX	XCRYPTCTR	TODO
XCRYPTCFB		CYRIX	XCRYPTCFB	TODO
XCRYPTOFB		CYRIX	XCRYPTOFB	TODO
MONTMUL		CYRIX	MONTMUL	TODO
XSHA1		CYRIX	XSHA1	TODO
XSHA256		CYRIX	XSHA256	TODO
PFRCPV	MM,MM/MEM	CYRIX	PFRCPV MM,MM/MEM	TODO
PFRSQRTV	MM,MM/MEM	CYRIX	PFRSQRTV MM,MM/MEM	TODO
SMINT		CYRIX	SMINT	TODO
SMINTOLD		CYRIX	SMINTOLD	TODO
RDM		CYRIX	RDM	TTODO
BB0_RESET		CYRIX	BB0_RESET	TODO
BB1_RESET		CYRIX	BB1_RESET	TODO
CPU_READ		CYRIX	CPU_READ	TODO
CPU_WRITE		CYRIX	CPU_WRITE	TODO
DMINT		CYRIX	DMINT	TODO
;CYRIX M ====================================================================
RDSHR	R/M32	CYRIXM	RDSHR R/M32	TODO
SVDC	M80,REG_SREG	CYRIXM	SVDC M80, REG_SREG	TODO
SVLDT	M80	CYRIXM	SVLDT M80	TODO
SVTS	M80	CYRIXM	SVTS M80	TODO
RSDC	REG_SREG,M80	CYRIXM	RSDC REG_SREG, M80	TODO
RSLDT	M80	CYRIXM	RSLDT M80	TODO

RSTS	M80	CYRIXM	RSTS M80	TODO
WRSHR	R/M32	CYRIXM	WRSHR R/M32	TODO
;AMD ====================================================================
INVLPGA	AX,ECX	AMD	INVLPGA AX,ECX	TODO
INVLPGA	EAX,ECX	AMD	INVLPGA EAX,ECX	TODO
INVLPGA	RAX,ECX	AMD	INVLPGA RAX,ECX	TODO
INVLPGA		AMD	INVLPGA 	TODO
CLZERO		X64,FUTURE,AMD	CLZERO 	TODO: X64,FUTURE,AMD

;AMD VMX ====================================================================
CLGI		VMX,AMD	CLGI 	TODO: VMX,AMD	
STGI		VMX,AMD	STGI 	TODO: VMX,AMD	
VMLOAD		VMX,AMD	VMLOAD 	TODO: VMX,AMD	
VMMCALL		VMX,AMD	VMMCALL 	TODO: VMX,AMD	
VMRUN		VMX,AMD	VMRUN 	TODO: VMX,AMD	
VMSAVE		VMX,AMD	VMSAVE 	TODO: VMX,AMD	
;INTEL VMX ====================================================================

VMXON	MEM	VMX	VMXON MEM	Takes a single 64-bit source operand in memory. It causes a logical processor to enter VMX root operation and to use the memory referenced by the operand to support VMX operation
VMPTRLD	MEM	VMX	VMPTRLD MEM	Takes a single 64-bit source operand in memory. It makes the referenced VMCS active and current
VMPTRST	MEM	VMX	VMPTRST MEM	Takes a single 64-bit destination operand that is in memory. Current-VMCS pointer is stored into the destination operand
VMCLEAR	MEM	VMX	VMCLEAR MEM	Takes a single 64-bit operand in memory. The instruction sets the launch state of the VMCS referenced by the operand to "clear", renders that VMCS inactive, and ensures that data for the VMCS have been written to the VMCS-data area in the referenced VMCS region
VMREAD	R/M32,R32	VMX	VMREAD R/M32,R32	Reads a component from the VMCS (the encoding of that field is given in a register operand) and stores it into a destination operand
VMREAD	R/M64,R64	VMX	VMREAD R/M64,R64	Reads a component from the VMCS (the encoding of that field is given in a register operand) and stores it into a destination operand
VMWRITE	R32,R/M32	VMX	VMWRITE R32,R/M32	Writes a component to the VMCS (the encoding of that field is given in a register operand) from a source operand
VMWRITE	R64,R/M64	VMX	VMWRITE R64,R/M64	Writes a component to the VMCS (the encoding of that field is given in a register operand) from a source operand
VMLAUNCH		VMX	VMLAUNCH 	Launches a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM
VMRESUME		VMX	VMRESUME 	Resumes a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM
VMXOFF		VMX	VMXOFF 	Causes the processor to leave VMX operation

INVEPT	R32,MEM	VMX	INVEPT R32,MEM	Invalidate cached EPT mappings in the processor to synchronize address translation in virtual machines with memory-resident EPT pages
INVEPT	R64,MEM	VMX,LONG	INVEPT R64,MEM	Invalidate cached EPT mappings in the processor to synchronize address translation in virtual machines with memory-resident EPT pages
INVVPID	R32,MEM	VMX	INVVPID R32,MEM	Invalidate cached mappings of address translation based on the Virtual Processor ID (VPID)
INVVPID	R64,MEM	VMX,LONG	INVVPID R64,MEM	Invalidate cached mappings of address translation based on the Virtual Processor ID (VPID)

VMCALL		VMX	VMCALL	Allows a guest in VMX non-root operation to call the VMM for service. A VM exit occurs, transferring control to the VMM
VMFUNC		VMX	VMFUNC 	This instruction allows software in VMX non-root operation to invoke a VM function, which is processor functionality enabled and configured by software in VMX root operation. No VM exit occurs

;AMD ====================================================================
LZCNT	R16,R/M16	AMD	LZCNT R16,R/M16	Leading Zero Count
LZCNT	R32,R/M32	AMD	LZCNT R32,R/M32	Leading Zero Count
LZCNT	R64,R/M64	AMD	LZCNT r64,R/M64	Leading Zero Count
LLWPCB	R32	AMD,386	LLWPCB R32	TODO: AMD,386,X64
LLWPCB	R64	AMD,X64	LLWPCB r64	TODO: AMD,386,X64
SLWPCB	R32	AMD,386	SLWPCB R32	TODO: AMD,386,X64
SLWPCB	R64	AMD,X64	SLWPCB r64	TODO: AMD,386,X64
LWPVAL	R32,R/M32,IMM32	AMD,386	LWPVAL R32, R/M32, IMM32	TODO: AMD,386
LWPVAL	R64,R/M32,IMM32	AMD,X64	LWPVAL r64, R/M32, IMM32	TODO: AMD,X64
LWPINS	R32,R/M32,IMM32	AMD,386	LWPINS R32, R/M32, IMM32	TODO: AMD,386
LWPINS	R64,R/M32,IMM32	AMD,X64	LWPINS r64, R/M32, IMM32	TODO: AMD,X64
;AMD SSE5 ====================================================================
VFMADDPD	XMM,XMM,XMM/M128,XMM	SSE5	VFMADDPD XMM,XMM,XMM/M128,XMM	TODO
VFMADDPD	YMM,YMM,YMM/M256,YMM	SSE5	VFMADDPD YMM,YMM,YMM/M256,YMM	TODO
VFMADDPD	XMM,XMM,XMM,XMM/M128	SSE5	VFMADDPD XMM,XMM,XMM,XMM/M128	TODO
VFMADDPD	YMM,YMM,YMM,YMM/M256	SSE5	VFMADDPD YMM,YMM,YMM,YMM/M256	TODO
VFMADDPS	XMM,XMM,XMM/M128,XMM	SSE5	VFMADDPS XMM,XMM,XMM/M128,XMM	TODO
VFMADDPS	YMM,YMM,YMM/M256,YMM	SSE5	VFMADDPS YMM,YMM,YMM/M256,YMM	TODO
VFMADDPS	XMM,XMM,XMM,XMM/M128	SSE5	VFMADDPS XMM,XMM,XMM,XMM/M128	TODO
VFMADDPS	YMM,YMM,YMM,YMM/M256	SSE5	VFMADDPS YMM,YMM,YMM,YMM/M256	TODO
VFMADDSD	XMM,XMM,XMM/M64,XMM	SSE5	VFMADDSD XMM,XMM,XMM/M64,XMM	TODO
VFMADDSD	XMM,XMM,XMM,XMM/M64	SSE5	VFMADDSD XMM,XMM,XMM,XMM/M64	TODO
VFMADDSS	XMM,XMM,XMM/M32,XMM	SSE5	VFMADDSS XMM,XMM,XMM/M32,XMM	TODO
VFMADDSS	XMM,XMM,XMM,XMM/M32	SSE5	VFMADDSS XMM,XMM,XMM,XMM/M32	TODO
VFMADDSUBPD	XMM,XMM,XMM/M128,XMM	SSE5	VFMADDSUBPD XMM,XMM,XMM/M128,XMM	TODO
VFMADDSUBPD	YMM,YMM,YMM/M256,YMM	SSE5	VFMADDSUBPD YMM,YMM,YMM/M256,YMM	TODO
VFMADDSUBPD	XMM,XMM,XMM,XMM/M128	SSE5	VFMADDSUBPD XMM,XMM,XMM,XMM/M128	TODO
VFMADDSUBPD	YMM,YMM,YMM,YMM/M256	SSE5	VFMADDSUBPD YMM,YMM,YMM,YMM/M256	TODO
VFMADDSUBPS	XMM,XMM,XMM/M128,XMM	SSE5	VFMADDSUBPS XMM,XMM,XMM/M128,XMM	TODO
VFMADDSUBPS	YMM,YMM,YMM/M256,YMM	SSE5	VFMADDSUBPS YMM,YMM,YMM/M256,YMM	TODO
VFMADDSUBPS	XMM,XMM,XMM,XMM/M128	SSE5	VFMADDSUBPS XMM,XMM,XMM,XMM/M128	TODO
VFMADDSUBPS	YMM,YMM,YMM,YMM/M256	SSE5	VFMADDSUBPS YMM,YMM,YMM,YMM/M256	TODO
VFMSUBADDPD	XMM,XMM,XMM/M128,XMM	SSE5	VFMSUBADDPD XMM,XMM,XMM/M128,XMM	TODO
VFMSUBADDPD	YMM,YMM,YMM/M256,YMM	SSE5	VFMSUBADDPD YMM,YMM,YMM/M256,YMM	TODO
VFMSUBADDPD	XMM,XMM,XMM,XMM/M128	SSE5	VFMSUBADDPD XMM,XMM,XMM,XMM/M128	TODO
VFMSUBADDPD	YMM,YMM,YMM,YMM/M256	SSE5	VFMSUBADDPD YMM,YMM,YMM,YMM/M256	TODO
VFMSUBADDPS	XMM,XMM,XMM/M128,XMM	SSE5	VFMSUBADDPS XMM,XMM,XMM/M128,XMM	TODO
VFMSUBADDPS	YMM,YMM,YMM/M256,YMM	SSE5	VFMSUBADDPS YMM,YMM,YMM/M256,YMM	TODO
VFMSUBADDPS	XMM,XMM,XMM,XMM/M128	SSE5	VFMSUBADDPS XMM,XMM,XMM,XMM/M128	TODO
VFMSUBADDPS	YMM,YMM,YMM,YMM/M256	SSE5	VFMSUBADDPS YMM,YMM,YMM,YMM/M256	TODO
VFMSUBPD	XMM,XMM,XMM/M128,XMM	SSE5	VFMSUBPD XMM,XMM,XMM/M128,XMM	TODO
VFMSUBPD	YMM,YMM,YMM/M256,YMM	SSE5	VFMSUBPD YMM,YMM,YMM/M256,YMM	TODO
VFMSUBPD	XMM,XMM,XMM,XMM/M128	SSE5	VFMSUBPD XMM,XMM,XMM,XMM/M128	TODO
VFMSUBPD	YMM,YMM,YMM,YMM/M256	SSE5	VFMSUBPD YMM,YMM,YMM,YMM/M256	TODO
VFMSUBPS	XMM,XMM,XMM/M128,XMM	SSE5	VFMSUBPS XMM,XMM,XMM/M128,XMM	TODO
VFMSUBPS	YMM,YMM,YMM/M256,YMM	SSE5	VFMSUBPS YMM,YMM,YMM/M256,YMM	TODO
VFMSUBPS	XMM,XMM,XMM,XMM/M128	SSE5	VFMSUBPS XMM,XMM,XMM,XMM/M128	TODO
VFMSUBPS	YMM,YMM,YMM,YMM/M256	SSE5	VFMSUBPS YMM,YMM,YMM,YMM/M256	TODO
VFMSUBSD	XMM,XMM,XMM/M64,XMM	SSE5	VFMSUBSD XMM,XMM,XMM/M64,XMM	TODO
VFMSUBSD	XMM,XMM,XMM,XMM/M64	SSE5	VFMSUBSD XMM,XMM,XMM,XMM/M64	TODO
VFMSUBSS	XMM,XMM,XMM/M32,XMM	SSE5	VFMSUBSS XMM,XMM,XMM/M32,XMM	TODO
VFMSUBSS	XMM,XMM,XMM,XMM/M32	SSE5	VFMSUBSS XMM,XMM,XMM,XMM/M32	TODO
VFNMADDPD	XMM,XMM,XMM/M128,XMM	SSE5	VFNMADDPD XMM,XMM,XMM/M128,XMM	TODO
VFNMADDPD	YMM,YMM,YMM/M256,YMM	SSE5	VFNMADDPD YMM,YMM,YMM/M256,YMM	TODO
VFNMADDPD	XMM,XMM,XMM,XMM/M128	SSE5	VFNMADDPD XMM,XMM,XMM,XMM/M128	TODO
VFNMADDPD	YMM,YMM,YMM,YMM/M256	SSE5	VFNMADDPD YMM,YMM,YMM,YMM/M256	TODO
VFNMADDPS	XMM,XMM,XMM/M128,XMM	SSE5	VFNMADDPS XMM,XMM,XMM/M128,XMM	TODO
VFNMADDPS	YMM,YMM,YMM/M256,YMM	SSE5	VFNMADDPS YMM,YMM,YMM/M256,YMM	TODO
VFNMADDPS	XMM,XMM,XMM,XMM/M128	SSE5	VFNMADDPS XMM,XMM,XMM,XMM/M128	TODO
VFNMADDPS	YMM,YMM,YMM,YMM/M256	SSE5	VFNMADDPS YMM,YMM,YMM,YMM/M256	TODO
VFNMADDSD	XMM,XMM,XMM/M64,XMM	SSE5	VFNMADDSD XMM,XMM,XMM/M64,XMM	TODO
VFNMADDSD	XMM,XMM,XMM,XMM/M64	SSE5	VFNMADDSD XMM,XMM,XMM,XMM/M64	TODO
VFNMADDSS	XMM,XMM,XMM/M32,XMM	SSE5	VFNMADDSS XMM,XMM,XMM/M32,XMM	TODO
VFNMADDSS	XMM,XMM,XMM,XMM/M32	SSE5	VFNMADDSS XMM,XMM,XMM,XMM/M32	TODO
VFNMSUBPD	XMM,XMM,XMM/M128,XMM	SSE5	VFNMSUBPD XMM,XMM,XMM/M128,XMM	TODO
VFNMSUBPD	YMM,YMM,YMM/M256,YMM	SSE5	VFNMSUBPD YMM,YMM,YMM/M256,YMM	TODO
VFNMSUBPD	XMM,XMM,XMM,XMM/M128	SSE5	VFNMSUBPD XMM,XMM,XMM,XMM/M128	TODO
VFNMSUBPD	YMM,YMM,YMM,YMM/M256	SSE5	VFNMSUBPD YMM,YMM,YMM,YMM/M256	TODO
VFNMSUBPS	XMM,XMM,XMM/M128,XMM	SSE5	VFNMSUBPS XMM,XMM,XMM/M128,XMM	TODO
VFNMSUBPS	YMM,YMM,YMM/M256,YMM	SSE5	VFNMSUBPS YMM,YMM,YMM/M256,YMM	TODO
VFNMSUBPS	XMM,XMM,XMM,XMM/M128	SSE5	VFNMSUBPS XMM,XMM,XMM,XMM/M128	TODO
VFNMSUBPS	YMM,YMM,YMM,YMM/M256	SSE5	VFNMSUBPS YMM,YMM,YMM,YMM/M256	TODO
VFNMSUBSD	XMM,XMM,XMM/M64,XMM	SSE5	VFNMSUBSD XMM,XMM,XMM/M64,XMM	TODO
VFNMSUBSD	XMM,XMM,XMM,XMM/M64	SSE5	VFNMSUBSD XMM,XMM,XMM,XMM/M64	TODO
VFNMSUBSS	XMM,XMM,XMM/M32,XMM	SSE5	VFNMSUBSS XMM,XMM,XMM/M32,XMM	TODO
VFNMSUBSS	XMM,XMM,XMM,XMM/M32	SSE5	VFNMSUBSS XMM,XMM,XMM,XMM/M32	TODO
VFRCZPD	XMM,XMM/M128	SSE5	VFRCZPD XMM,XMM/M128	TODO
VFRCZPD	YMM,YMM/M256	SSE5	VFRCZPD YMM,YMM/M256	TODO
VFRCZPS	XMM,XMM/M128	SSE5	VFRCZPS XMM,XMM/M128	TODO
VFRCZPS	YMM,YMM/M256	SSE5	VFRCZPS YMM,YMM/M256	TODO
VFRCZSD	XMM,XMM/M64	SSE5	VFRCZSD XMM,XMM/M64	TODO
VFRCZSS	XMM,XMM/M32	SSE5	VFRCZSS XMM,XMM/M32	TODO
VPCMOV	XMM,XMM,XMM/M128,XMM	SSE5	VPCMOV XMM,XMM,XMM/M128,XMM	TODO
VPCMOV	YMM,YMM,YMM/M256,YMM	SSE5	VPCMOV YMM,YMM,YMM/M256,YMM	TODO
VPCMOV	XMM,XMM,XMM,XMM/M128	SSE5	VPCMOV XMM,XMM,XMM,XMM/M128	TODO
VPCMOV	YMM,YMM,YMM,YMM/M256	SSE5	VPCMOV YMM,YMM,YMM,YMM/M256	TODO
VPCOMB	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMB XMM,XMM,XMM/M128,IMM8	TODO
VPCOMD	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMD XMM,XMM,XMM/M128,IMM8	TODO
VPCOMQ	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMQ XMM,XMM,XMM/M128,IMM8	TODO
VPCOMUB	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMUB XMM,XMM,XMM/M128,IMM8	TODO
VPCOMUD	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMUD XMM,XMM,XMM/M128,IMM8	TODO
VPCOMUQ	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMUQ XMM,XMM,XMM/M128,IMM8	TODO
VPCOMUW	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMUW XMM,XMM,XMM/M128,IMM8	TODO
VPCOMW	XMM,XMM,XMM/M128,IMM8	SSE5	VPCOMW XMM,XMM,XMM/M128,IMM8	TODO
VPHADDBD	XMM,XMM/M128	SSE5	VPHADDBD XMM,XMM/M128	TODO
VPHADDBQ	XMM,XMM/M128	SSE5	VPHADDBQ XMM,XMM/M128	TODO
VPHADDBW	XMM,XMM/M128	SSE5	VPHADDBW XMM,XMM/M128	TODO
VPHADDDQ	XMM,XMM/M128	SSE5	VPHADDDQ XMM,XMM/M128	TODO
VPHADDUBD	XMM,XMM/M128	SSE5	VPHADDUBD XMM,XMM/M128	TODO
VPHADDUBQ	XMM,XMM/M128	SSE5	VPHADDUBQ XMM,XMM/M128	TODO
VPHADDUBW	XMM,XMM/M128	SSE5	VPHADDUBW XMM,XMM/M128	TODO
VPHADDUDQ	XMM,XMM/M128	SSE5	VPHADDUDQ XMM,XMM/M128	TODO
VPHADDUWD	XMM,XMM/M128	SSE5	VPHADDUWD XMM,XMM/M128	TODO
VPHADDUWQ	XMM,XMM/M128	SSE5	VPHADDUWQ XMM,XMM/M128	TODO
VPHADDWD	XMM,XMM/M128	SSE5	VPHADDWD XMM,XMM/M128	TODO
VPHADDWQ	XMM,XMM/M128	SSE5	VPHADDWQ XMM,XMM/M128	TODO
VPHSUBBW	XMM,XMM/M128	SSE5	VPHSUBBW XMM,XMM/M128	TODO
VPHSUBDQ	XMM,XMM/M128	SSE5	VPHSUBDQ XMM,XMM/M128	TODO
VPHSUBWD	XMM,XMM/M128	SSE5	VPHSUBWD XMM,XMM/M128	TODO
VPMACSDD	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSDD XMM,XMM,XMM/M128,XMM	TODO
VPMACSDQH	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSDQH XMM,XMM,XMM/M128,XMM	TODO
VPMACSDQL	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSDQL XMM,XMM,XMM/M128,XMM	TODO
VPMACSSDD	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSSDD XMM,XMM,XMM/M128,XMM	TODO
VPMACSSDQH	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSSDQH XMM,XMM,XMM/M128,XMM	TODO
VPMACSSDQL	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSSDQL XMM,XMM,XMM/M128,XMM	TODO
VPMACSSWD	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSSWD XMM,XMM,XMM/M128,XMM	TODO
VPMACSSWW	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSSWW XMM,XMM,XMM/M128,XMM	TODO
VPMACSWD	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSWD XMM,XMM,XMM/M128,XMM	TODO
VPMACSWW	XMM,XMM,XMM/M128,XMM	SSE5	VPMACSWW XMM,XMM,XMM/M128,XMM	TODO
VPMADCSSWD	XMM,XMM,XMM/M128,XMM	SSE5	VPMADCSSWD XMM,XMM,XMM/M128,XMM	TODO
VPMADCSWD	XMM,XMM,XMM/M128,XMM	SSE5	VPMADCSWD XMM,XMM,XMM/M128,XMM	TODO
VPPERM	XMM,XMM,XMM,XMM/M128	SSE5	VPPERM XMM,XMM,XMM,XMM/M128	TODO
VPPERM	XMM,XMM,XMM/M128,XMM	SSE5	VPPERM XMM,XMM,XMM/M128,XMM	TODO
VPROTB	XMM,XMM/M128,XMM	SSE5	VPROTB XMM,XMM/M128, XMM	TODO
VPROTB	XMM,XMM,XMM/M128	SSE5	VPROTB XMM,XMM,XMM/M128	TODO
VPROTB	XMM,XMM/M128,IMM8	SSE5	VPROTB XMM,XMM/M128, IMM8	TODO
VPROTD	XMM,XMM/M128,XMM	SSE5	VPROTD XMM,XMM/M128, XMM	TODO
VPROTD	XMM,XMM,XMM/M128	SSE5	VPROTD XMM,XMM,XMM/M128	TODO
VPROTD	XMM,XMM/M128,IMM8	SSE5	VPROTD XMM,XMM/M128, IMM8	TODO
VPROTQ	XMM,XMM/M128,XMM	SSE5	VPROTQ XMM,XMM/M128, XMM	TODO
VPROTQ	XMM,XMM,XMM/M128	SSE5	VPROTQ XMM,XMM,XMM/M128	TODO
VPROTQ	XMM,XMM/M128,IMM8	SSE5	VPROTQ XMM,XMM/M128, IMM8	TODO
VPROTW	XMM,XMM/M128,XMM	SSE5	VPROTW XMM,XMM/M128, XMM	TODO
VPROTW	XMM,XMM,XMM/M128	SSE5	VPROTW XMM,XMM,XMM/M128	TODO
VPROTW	XMM,XMM/M128,IMM8	SSE5	VPROTW XMM,XMM/M128, IMM8	TODO
VPSHAB	XMM,XMM/M128,XMM	SSE5	VPSHAB XMM,XMM/M128, XMM	TODO
VPSHAB	XMM,XMM,XMM/M128	SSE5	VPSHAB XMM,XMM,XMM/M128	TODO
VPSHAD	XMM,XMM/M128,XMM	SSE5	VPSHAD XMM,XMM/M128, XMM	TODO
VPSHAD	XMM,XMM,XMM/M128	SSE5	VPSHAD XMM,XMM,XMM/M128	TODO
VPSHAQ	XMM,XMM/M128,XMM	SSE5	VPSHAQ XMM,XMM/M128, XMM	TODO
VPSHAQ	XMM,XMM,XMM/M128	SSE5	VPSHAQ XMM,XMM,XMM/M128	TODO
VPSHAW	XMM,XMM/M128,XMM	SSE5	VPSHAW XMM,XMM/M128, XMM	TODO
VPSHAW	XMM,XMM,XMM/M128	SSE5	VPSHAW XMM,XMM,XMM/M128	TODO
VPSHLB	XMM,XMM/M128,XMM	SSE5	VPSHLB XMM,XMM/M128, XMM	TODO
VPSHLB	XMM,XMM,XMM/M128	SSE5	VPSHLB XMM,XMM,XMM/M128	TODO
VPSHLD	XMM,XMM/M128,XMM	SSE5	VPSHLD XMM,XMM/M128, XMM	TODO
VPSHLD	XMM,XMM,XMM/M128	SSE5	VPSHLD XMM,XMM,XMM/M128	TODO
VPSHLQ	XMM,XMM/M128,XMM	SSE5	VPSHLQ XMM,XMM/M128, XMM	TODO
VPSHLQ	XMM,XMM,XMM/M128	SSE5	VPSHLQ XMM,XMM,XMM/M128	TODO
VPSHLW	XMM,XMM/M128,XMM	SSE5	VPSHLW XMM,XMM/M128, XMM	TODO
VPSHLW	XMM,XMM,XMM/M128	SSE5	VPSHLW XMM,XMM,XMM/M128	TODO
;AMD SSE4A ====================================================================
EXTRQ	XMM,IMM,IMM	SSE4A	EXTRQ XMM, IMM, IMM	TODO
EXTRQ	XMM,XMM	SSE4A	EXTRQ XMM,XMM	TODO
INSERTQ	XMM,XMM,IMM,IMM	SSE4A	INSERTQ XMM,XMM, IMM, IMM	TODO
INSERTQ	XMM,XMM	SSE4A	INSERTQ XMM,XMM	TODO
MOVNTSD	MEM,XMM	SSE4A	MOVNTSD MEM, XMM	TODO
MOVNTSS	MEM,XMM	SSE4A	MOVNTSS MEM, XMM	TODO: SSE4A,
;AMD 3DNOW;====================================================================
FEMMS		3DNOW	FEMMS 	TODO: PENT,3DNOW
PF2IW	MM,MM/MEM	3DNOW	PF2IW MM,MM/MEM	TODO: PENT,3DNOW
PFNACC	MM,MM/MEM	3DNOW	PFNACC MM,MM/MEM	TODO: PENT,3DNOW
PFPNACC	MM,MM/MEM	3DNOW	PFPNACC MM,MM/MEM	TODO: PENT,3DNOW
PI2FW	MM,MM/MEM	3DNOW	PI2FW MM,MM/MEM	TODO: PENT,3DNOW
PSWAPD	MM,MM/MEM	3DNOW	PSWAPD MM,MM/MEM	TODO: PENT,3DNOW
PF2ID	MM,MM/MEM	3DNOW	PF2ID MM,MM/MEM	TODO: PENT,3DNOW
PFACC	MM,MM/MEM	3DNOW	PFACC MM,MM/MEM	TODO: PENT,3DNOW
PFADD	MM,MM/MEM	3DNOW	PFADD MM,MM/MEM	TODO: PENT,3DNOW
PFCMPEQ	MM,MM/MEM	3DNOW	PFCMPEQ MM,MM/MEM	TODO: PENT,3DNOW
PFCMPGE	MM,MM/MEM	3DNOW	PFCMPGE MM,MM/MEM	TODO: PENT,3DNOW
PFCMPGT	MM,MM/MEM	3DNOW	PFCMPGT MM,MM/MEM	TODO: PENT,3DNOW
PFMAX	MM,MM/MEM	3DNOW	PFMAX MM,MM/MEM	TODO: PENT,3DNOW
PFMIN	MM,MM/MEM	3DNOW	PFMIN MM,MM/MEM	TODO: PENT,3DNOW
PFMUL	MM,MM/MEM	3DNOW	PFMUL MM,MM/MEM	TODO: PENT,3DNOW
PFRCP	MM,MM/MEM	3DNOW	PFRCP MM,MM/MEM	TODO: PENT,3DNOW
PFRCPIT1	MM,MM/MEM	3DNOW	PFRCPIT1 MM,MM/MEM	TODO: PENT,3DNOW
PFRCPIT2	MM,MM/MEM	3DNOW	PFRCPIT2 MM,MM/MEM	TODO: PENT,3DNOW
PFRSQIT1	MM,MM/MEM	3DNOW	PFRSQIT1 MM,MM/MEM	TODO: PENT,3DNOW
PFRSQRT	MM,MM/MEM	3DNOW	PFRSQRT MM,MM/MEM	TODO: PENT,3DNOW
PFSUB	MM,MM/MEM	3DNOW	PFSUB MM,MM/MEM	TODO: PENT,3DNOW
PFSUBR	MM,MM/MEM	3DNOW	PFSUBR MM,MM/MEM	TODO: PENT,3DNOW
PI2FD	MM,MM/MEM	3DNOW	PI2FD MM,MM/MEM	TODO: PENT,3DNOW
PPMULHRWA	MM,MM/MEM	3DNOW	PMULHRWA MM,MM/MEM	TODO: PENT,3DNOW
PAVGUSB	MM,MM/MEM	3DNOW	PAVGUSB MM,MM/MEM	TODO: PENT,3DNOW
PREFETCH	MEM	3DNOW	PREFETCH MEM	TODO: PENT,3DNOW
PREFETCHW	MEM	3DNOW	PREFETCHW MEM	Prefetch Data into Caches in Anticipation of a Write
;AMD: Trailing Bit Manipulation (TBM) ====================================================================
TZMSK	R32,R/M32	TBM	TZMSK R32, R/M32	TODO: AMD, Trailing Bit Manipulation
TZMSK	R64,R/M64	TBM	TZMSK R64, R/M64	TODO: AMD, Trailing Bit Manipulation
T1MSKC	R32,R/M32	TBM	T1MSKC R32, R/M32	TODO: AMD, Trailing Bit Manipulation
T1MSKC	R64,R/M64	TBM	T1MSKC R64, R/M64	TODO: AMD, Trailing Bit Manipulation
;Undocumented INTEL ====================================================================
FFREEP	ST	UNDOC	FFREEP ST	TODO: 286,UNDOC	
FFREEP		UNDOC	FFREEP 	TODO: 286,UNDOC	
IBTS	MEM,R16	UNDOC	IBTS MEM,R16	TODO: 386,UNDOC
IBTS	R16,R16	UNDOC	IBTS R16,R16	TODO: 386,UNDOC
IBTS	MEM,R32	UNDOC	IBTS MEM,R32	TODO: 386,UNDOC
IBTS	R32,R32	UNDOC	IBTS R32,R32	TODO: 386,UNDOC
CMPXCHG486	MEM,R8	UNDOC	CMPXCHG486 MEM,R8	TODO: 486,UNDOC
CMPXCHG486	R8,R8	UNDOC	CMPXCHG486 R8,R8	TODO: 486,UNDOC
CMPXCHG486	MEM,R16	UNDOC	CMPXCHG486 MEM,R16	TODO: 486,UNDOC
CMPXCHG486	R16,R16	UNDOC	CMPXCHG486 R16,R16	TODO: 486,UNDOC
CMPXCHG486	MEM,R32	UNDOC	CMPXCHG486 MEM,R32	TODO: 486,UNDOC
CMPXCHG486	R32,R32	UNDOC	CMPXCHG486 R32,R32	TODO: 486,UNDOC
SMI		UNDOC	SMI 	TODO: 386,UNDOC
UMOV	MEM,R8	UNDOC	UMOV MEM,R8	TODO: 386,UNDOC
UMOV	R8,R8	UNDOC	UMOV R8,R8	TODO: 386,UNDOC
UMOV	MEM,R16	UNDOC	UMOV MEM,R16	TODO: 386,UNDOC
UMOV	R16,R16	UNDOC	UMOV R16,R16	TODO: 386,UNDOC
UMOV	MEM,R32	UNDOC	UMOV MEM,R32	TODO: 386,UNDOC
UMOV	R32,R32	UNDOC	UMOV R32,R32	TODO: 386,UNDOC
UMOV	R8,MEM	UNDOC	UMOV R8,MEM	TODO: 386,UNDOC
UMOV	R8,R8	UNDOC	UMOV R8,R8	TODO: 386,UNDOC
UMOV	R16,MEM	UNDOC	UMOV R16,MEM	TODO: 386,UNDOC
UMOV	R16,R16	UNDOC	UMOV R16,R16	TODO: 386,UNDOC
UMOV	R32,MEM	UNDOC	UMOV R32,MEM	TODO: 386,UNDOC
UMOV	R32,R32	UNDOC	UMOV R32,R32	TODO: 386,UNDOC
XBTS	R16,MEM	UNDOC	XBTS R16,MEM	TODO: 386,UNDOC
XBTS	R16,R16	UNDOC	XBTS R16,R16	TODO: 386,UNDOC
XBTS	R32,MEM	UNDOC	XBTS R32,MEM	TODO: 386,UNDOC
XBTS	R32,R32	UNDOC	XBTS R32,R32	TODO: 386,UNDOC
SALC		UNDOC	SALC 	TODO: 8086,UNDOC	
LOADALL		UNDOC	LOADALL 	TODO: 386,UNDOC	
LOADALL286		UNDOC	LOADALL286 	TODO: 286,UNDOC	
;IA64 ====================================================================
JMPE	IMM	IA64	JMPE IMM	TODO
JMPE	IMM16	IA64	JMPE IMM16	TODO
JMPE	IMM32	IA64	JMPE IMM32	TODO
JMPE	R/M16	IA64	JMPE R/M16	TODO
JMPE	R/M32	IA64	JMPE R/M32	TODO
; INTEL ====================================================================
JMP	M16	8086	JMP M16:16	Jump far, absolute indirect, address given in m16
JMP	M32	386	JMP M16:32	Jump far, absolute indirect, address given in M32.
JMP	M64	X64	JMP M16:64	Jump far, absolute indirect, address given in M64.
JMP	R/M16	8086	JMP R/M16	Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode.
JMP	R/M32	386	JMP R/M32	Jump near, absolute indirect, address given in r/M32. Not supported in 64-bit mode.
JMP	R/M64	X64	JMP R/M64	Jump near, absolute indirect, RIP = 64-Bit offset from register or memory.
JMP	REL8	8086	JMP REL8	Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits.
JMP	REL16	8086	JMP REL16	Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode.
JMP	REL32	386	JMP REL32	Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits.
;====================================================================
SETA	R/M8	386	SETA r/m8	Set byte if above (CF=0 and ZF=0) (SETA=SETNBE)
SETAE	R/M8	386	SETAE r/m8	Set byte if above or equal (CF=0) (SETAE=SETNC=SETNB)
SETB	R/M8	386	SETB r/m8	Set byte if below (CF=1) (SETB=SETC=SETNAE)
SETBE	R/M8	386	SETBE r/m8	Set byte if below or equal (CF=1 or ZF=1) (SETBE=SETNA)
SETC	R/M8	386	SETC r/m8	Set byte if carry (CF=1 SETB=SETC=SETNAE)
SETE	R/M8	386	SETE r/m8	Set byte if equal (ZF=1) (SETE=SETZ)
SETG	R/M8	386	SETG r/m8	Set byte if greater (ZF=0 and SF=OF) (SETG=SETNLE)
SETGE	R/M8	386	SETGE r/m8	Set byte if greater or equal (SF=OF) (SETGE=SETNL)
SETL	R/M8	386	SETL r/m8	Set byte if less (SF!=OF) (SETL=SETNGE)
SETLE	R/M8	386	SETLE r/m8	Set byte if less or equal (ZF=1 or SF!=OF) (SETLE=SETNG)
SETNA	R/M8	386	SETNA r/m8	Set byte if not above (CF=1 or ZF=1) (SETBE=SETNA)
SETNAE	R/M8	386	SETNAE r/m8	Set byte if not above or equal (CF=1) (SETB=SETC=SETNAE)
SETNB	R/M8	386	SETNB r/m8	Set byte if not below (CF=0) (SETAE=SETNC=SETNB)
SETNBE	R/M8	386	SETNBE r/m8	Set byte if not below or equal (CF=0 and ZF=0) (SETA=SETNBE)
SETNC	R/M8	386	SETNC r/m8	Set byte if not carry (CF=0) (SETAE=SETNC=SETNB)
SETNE	R/M8	386	SETNE r/m8	Set byte if not equal (ZF=0) (SETNE=SETNZ)
SETNG	R/M8	386	SETNG r/m8	Set byte if not greater (ZF=1 or SF!=OF) (SETLE=SETNG)
SETNGE	R/M8	386	SETNGE r/m8	Set byte if not greater or equal (SF!=OF) (SETL=SETNGE)
SETNL	R/M8	386	SETNL r/m8	Set byte if not less (SF=OF) (SETGE=SETNL)
SETNLE	R/M8	386	SETNLE r/m8	Set byte if not less or equal (ZF=0 and SF=OF) (SETG=SETNLE)
SETNO	R/M8	386	SETNO r/m8	Set byte if not overflow (OF=0)
SETNP	R/M8	386	SETNP r/m8	Set byte if not parity (PF=0) (SETNP=SETPO)
SETNS	R/M8	386	SETNS r/m8	Set byte if not sign (SF=0)
SETNZ	R/M8	386	SETNZ r/m8	Set byte if not zero (ZF=0) (SETNE=SETNZ)
SETO	R/M8	386	SETO r/m8	Set byte if overflow (OF=1)
SETP	R/M8	386	SETP r/m8	Set byte if parity (PF=1) (SETP=SETPE)
SETPE	R/M8	386	SETPE r/m8	Set byte if parity even (PF=1) (SETP=SETPE)
SETPO	R/M8	386	SETPO r/m8	Set byte if parity odd (PF=0 SETNP=SETPO)
SETS	R/M8	386	SETS r/m8	Set byte if sign (SF=1)
SETZ	R/M8	386	SETZ r/m8	Set byte if zero (ZF=1) (SETE=SETZ)
;====================================================================
JCXZ	REL8	8086	JCXZ REL8	Jump short if CX register is 0.
JECXZ	REL8	386	JECXZ REL8	Jump short if ECX register is 0.
JRCXZ	REL8	X64	JRCXZ REL8	Jump short if RCX register is 0.
;====================================================================
JA	REL8	8086	JA REL8	Jump short if above (CF=0 and ZF=0) (JA=JNBE)
JAE	REL8	8086	JAE REL8	Jump short if above or equal (CF=0) (JAE=JNB)
JB	REL8	8086	JB REL8	Jump short if below (CF=1) (JB=JNAE)
JBE	REL8	8086	JBE REL8	Jump short if below or equal (CF=1 or ZF=1) (JBE=JNA)
JC	REL8	8086	JC REL8	Jump short if carry (CF=1)
JE	REL8	8086	JE REL8	Jump short if equal (ZF=1) (JE=JZ)
JG	REL8	8086	JG REL8	Jump short if greater (ZF=0 and SF=OF) (JG=JNLE)
JGE	REL8	8086	JGE REL8	Jump short if greater or equal (SF=OF) (JGE=JNL)
JL	REL8	8086	JL REL8	Jump short if less (SF!=OF) (JL=JNGE)
JLE	REL8	8086	JLE REL8	Jump short if less or equal (ZF=1 or SF!=OF) (JLE=JNG)
JNA	REL8	8086	JNA REL8	Jump short if not above (CF=1 or ZF=1) (JBE=JNA)
JNAE	REL8	8086	JNAE REL8	Jump short if not above or equal (CF=1) (JB=JNAE)
JNB	REL8	8086	JNB REL8	Jump short if not below (CF=0) (JAE=JNB)
JNBE	REL8	8086	JNBE REL8	Jump short if not below or equal (CF=0 and ZF=0) (JA=JNBE)
JNC	REL8	8086	JNC REL8	Jump short if not carry (CF=0)
JNE	REL8	8086	JNE REL8	Jump short if not equal (ZF=0) (JNE=JNZ)
JNG	REL8	8086	JNG REL8	Jump short if not greater (ZF=1 or SF!=OF) (JLE=JNG)
JNGE	REL8	8086	JNGE REL8	Jump short if not greater or equal (SF!=OF) (JL=JNGE)
JNL	REL8	8086	JNL REL8	Jump short if not less (SF=OF) (JGE=JNL)
JNLE	REL8	8086	JNLE REL8	Jump short if not less or equal (ZF=0 and SF=OF) (JG=JNLE)
JNO	REL8	8086	JNO REL8	Jump short if not overflow (OF=0)
JNP	REL8	8086	JNP REL8	Jump short if not parity (PF=0) (JNP=JPO)
JNS	REL8	8086	JNS REL8	Jump short if not sign (SF=0)
JNZ	REL8	8086	JNZ REL8	Jump short if not zero (ZF=0) (JNE=JNZ)
JO	REL8	8086	JO REL8	Jump short if overflow (OF=1)
JP	REL8	8086	JP REL8	Jump short if parity (PF=1) (JP=JPE)
JPE	REL8	8086	JPE REL8	Jump short if parity even (PF=1) (JP=JPE)
JPO	REL8	8086	JPO REL8	Jump short if parity odd (PF=0) (JNP=JPO)
JS	REL8	8086	JS REL8	Jump short if sign (SF=1)
JZ	REL8	8086	JZ REL8	Jump short if zero (ZF=1) (JE=JZ)
;====================================================================
JA	REL16	386	JA REL16	Jump near if above (CF=0 and ZF=0) (JA=JNBE). Not supported in 64-bit mode.
JAE	REL16	386	JAE REL16	Jump near if above or equal (CF=0) (JAE=JNB). Not supported in 64-bit mode.
JB	REL16	386	JB REL16	Jump near if below (CF=1) (JB=JNAE). Not supported in 64-bit mode.
JBE	REL16	386	JBE REL16	Jump near if below or equal (CF=1 or ZF=1) (JBE=JNA). Not supported in 64-bit mode.
JC	REL16	386	JC REL16	Jump near if carry (CF=1). Not supported in 64-bit mode.
JE	REL16	386	JE REL16	Jump near if equal (ZF=1) (JE=JZ). Not supported in 64-bit mode.
JG	REL16	386	JG REL16	Jump near if greater (ZF=0 and SF=OF) (JG=JNLE). Not supported in 64-bit mode.
JGE	REL16	386	JGE REL16	Jump near if greater or equal (SF=OF) (JGE=JNL). Not supported in 64-bit mode.
JL	REL16	386	JL REL16	Jump near if less (SF!=OF) (JL=JNGE). Not supported in 64-bit mode.
JLE	REL16	386	JLE REL16	Jump near if less or equal (ZF=1 or SF!=OF) (JLE=JNG). Not supported in 64-bit mode.
JNA	REL16	386	JNA REL16	Jump near if not above (CF=1 or ZF=1) (JBE=JNA). Not supported in 64-bit mode.
JNAE	REL16	386	JNAE REL16	Jump near if not above or equal (CF=1) (JB=JNAE). Not supported in 64-bit mode.
JNB	REL16	386	JNB REL16	Jump near if not below (CF=0) (JAE=JNB). Not supported in 64-bit mode.
JNBE	REL16	386	JNBE REL16	Jump near if not below or equal (CF=0 and ZF=0) (JA=JNBE). Not supported in 64-bit mode.
JNC	REL16	386	JNC REL16	Jump near if not carry (CF=0). Not supported in 64-bit mode.
JNE	REL16	386	JNE REL16	Jump near if not equal (ZF=0) (JNE=JNZ). Not supported in 64-bit mode.
JNG	REL16	386	JNG REL16	Jump near if not greater (ZF=1 or SF!=OF) (JLE=JNG). Not supported in 64-bit mode.
JNGE	REL16	386	JNGE REL16	Jump near if not greater or equal (SF!=OF) (JL=JNGE). Not supported in 64-bit mode.
JNL	REL16	386	JNL REL16	Jump near if not less (SF=OF) (JGE=JNL). Not supported in 64-bit mode.
JNLE	REL16	386	JNLE REL16	Jump near if not less or equal (ZF=0 and SF=OF) (JG=JNLE). Not supported in 64-bit mode.
JNO	REL16	386	JNO REL16	Jump near if not overflow (OF=0). Not supported in 64-bit mode.
JNP	REL16	386	JNP REL16	Jump near if not parity (PF=0) (JNP=JPO). Not supported in 64-bit mode.
JNS	REL16	386	JNS REL16	Jump near if not sign (SF=0). Not supported in 64-bit mode.
JNZ	REL16	386	JNZ REL16	Jump near if not zero (ZF=0) (JNE=JNZ). Not supported in 64-bit mode.
JO	REL16	386	JO REL16	Jump near if overflow (OF=1). Not supported in 64-bit mode.
JP	REL16	386	JP REL16	Jump near if parity (PF=1) (JP=JPE). Not supported in 64-bit mode.
JPE	REL16	386	JPE REL16	Jump near if parity even (PF=1) (JP=JPE). Not supported in 64-bit mode.
JPO	REL16	386	JPO REL16	Jump near if parity odd (PF=0) (JNP=JPO). Not supported in 64-bit mode.
JS	REL16	386	JS REL16	Jump near if sign (SF=1). Not supported in 64-bit mode.
JZ	REL16	386	JZ REL16	Jump near if zero (ZF=1) (JE=JZ). Not supported in 64-bit mode.
;====================================================================
JA	REL32	386	JA REL32	Jump near if above (CF=0 and ZF=0) (JA=JNBE)
JAE	REL32	386	JAE REL32	Jump near if above or equal (CF=0) (JAE=JNB)
JB	REL32	386	JB REL32	Jump near if below (CF=1) (JB=JNAE)
JBE	REL32	386	JBE REL32	Jump near if below or equal (CF=1 or ZF=1) (JBE=JNA)
JC	REL32	386	JC REL32	Jump near if carry (CF=1)
JE	REL32	386	JE REL32	Jump near if equal (ZF=1) (JE=JZ)
JG	REL32	386	JG REL32	Jump near if greater (ZF=0 and SF=OF) (JG=JNLE)
JGE	REL32	386	JGE REL32	Jump near if greater or equal (SF=OF) (JGE=JNL)
JL	REL32	386	JL REL32	Jump near if less (SF!=OF) (JL=JNGE)
JLE	REL32	386	JLE REL32	Jump near if less or equal (ZF=1 or SF!=OF) (JLE=JNG)
JNA	REL32	386	JNA REL32	Jump near if not above (CF=1 or ZF=1) (JBE=JNA)
JNAE	REL32	386	JNAE REL32	Jump near if not above or equal (CF=1) (JB=JNAE)
JNB	REL32	386	JNB REL32	Jump near if not below (CF=0) (JAE=JNB)
JNBE	REL32	386	JNBE REL32	Jump near if not below or equal (CF=0 and ZF=0) (JA=JNBE)
JNC	REL32	386	JNC REL32	Jump near if not carry (CF=0)
JNE	REL32	386	JNE REL32	Jump near if not equal (ZF=0) (JNE=JNZ)
JNG	REL32	386	JNG REL32	Jump near if not greater (ZF=1 or SF!=OF) (JLE=JNG)
JNGE	REL32	386	JNGE REL32	Jump near if not greater or equal (SF!=OF) (JL=JNGE)
JNL	REL32	386	JNL REL32	Jump near if not less (SF=OF) (JGE=JNL)
JNLE	REL32	386	JNLE REL32	Jump near if not less or equal (ZF=0 and SF=OF) (JG=JNLE)
JNO	REL32	386	JNO REL32	Jump near if not overflow (OF=0)
JNP	REL32	386	JNP REL32	Jump near if not parity (PF=0) (JNP=JPO)
JNS	REL32	386	JNS REL32	Jump near if not sign (SF=0)
JNZ	REL32	386	JNZ REL32	Jump near if not zero (ZF=0) (JNE=JNZ)
JO	REL32	386	JO REL32	Jump near if overflow (OF=1)
JP	REL32	386	JP REL32	Jump near if parity (PF=1) (JP=JPE)
JPE	REL32	386	JPE REL32	Jump near if parity even (PF=1) (JP=JPE)
JPO	REL32	386	JPO REL32	Jump near if parity odd (PF=0) (JNP=JPO)
JS	REL32	386	JS REL32	Jump near if sign (SF=1)
JZ	REL32	386	JZ REL32	Jump near if zero (ZF=1) (JE=JZ)
;====================================================================
JA	REL64	X64	JA REL64	Jump if above (CF=0 and ZF=0) (JA=JNBE)
JAE	REL64	X64	JAE REL64	Jump if above or equal (CF=0) (JAE=JNB)
JB	REL64	X64	JB REL64	Jump if below (CF=1) (JB=JNAE)
JBE	REL64	X64	JBE REL64	Jump if below or equal (CF=1 or ZF=1) (JBE=JNA)
JC	REL64	X64	JC REL64	Jump if carry (CF=1)
JE	REL64	X64	JE REL64	Jump if equal (ZF=1) (JE=JZ)
JG	REL64	X64	JG REL64	Jump if greater (ZF=0 and SF=OF) (JG=JNLE)
JGE	REL64	X64	JGE REL64	Jump if greater or equal (SF=OF) (JGE=JNL)
JL	REL64	X64	JL REL64	Jump if less (SF!=OF) (JL=JNGE)
JLE	REL64	X64	JLE REL64	Jump if less or equal (ZF=1 or SF!=OF) (JLE=JNG)
JNA	REL64	X64	JNA REL64	Jump if not above (CF=1 or ZF=1) (JBE=JNA)
JNAE	REL64	X64	JNAE REL64	Jump if not above or equal (CF=1) (JB=JNAE)
JNB	REL64	X64	JNB REL64	Jump if not below (CF=0) (JAE=JNB)
JNBE	REL64	X64	JNBE REL64	Jump if not below or equal (CF=0 and ZF=0) (JA=JNBE)
JNC	REL64	X64	JNC REL64	Jump if not carry (CF=0)
JNE	REL64	X64	JNE REL64	Jump if not equal (ZF=0) (JNE=JNZ)
JNG	REL64	X64	JNG REL64	Jump if not greater (ZF=1 or SF!=OF) (JLE=JNG)
JNGE	REL64	X64	JNGE REL64	Jump if not greater or equal (SF!=OF) (JL=JNGE)
JNL	REL64	X64	JNL REL64	Jump if not less (SF=OF) (JGE=JNL)
JNLE	REL64	X64	JNLE REL64	Jump if not less or equal (ZF=0 and SF=OF) (JG=JNLE)
JNO	REL64	X64	JNO REL64	Jump if not overflow (OF=0)
JNP	REL64	X64	JNP REL64	Jump if not parity (PF=0) (JNP=JPO)
JNS	REL64	X64	JNS REL64	Jump if not sign (SF=0)
JNZ	REL64	X64	JNZ REL64	Jump if not zero (ZF=0) (JNE=JNZ)
JO	REL64	X64	JO REL64	Jump if overflow (OF=1)
JP	REL64	X64	JP REL64	Jump if parity (PF=1) (JP=JPE)
JPE	REL64	X64	JPE REL64	Jump if parity even (PF=1) (JP=JPE)
JPO	REL64	X64	JPO REL64	Jump if parity odd (PF=0) (JNP=JPO)
JS	REL64	X64	JS REL64	Jump if sign (SF=1)
JZ	REL64	X64	JZ REL64	Jump if zero (ZF=1) (JE=JZ)
;====================================================================
CMOVA	R16,R/M16	P6	CMOVA R16, R/M16	Move r/m16 to r16 if above (CF=0 and ZF=0) (CMOVA=CMOVNBE)
CMOVAE	R16,R/M16	P6	CMOVAE R16, R/M16	Move r/m16 to r16 if above or equal (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVB	R16,R/M16	P6	CMOVB R16, R/M16	Move r/m16 to r16 if below (CF=1) (CMOVB=CMOVC=CMOVNAE)
CMOVBE	R16,R/M16	P6	CMOVBE R16, R/M16	Move r/m16 to r16 if below or equal (CF=1 or ZF=1) (CMOVBE=CMOVNA)
CMOVE	R16,R/M16	P6	CMOVE R16, R/M16	Move r/m16 to r16 if equal (ZF=1) (CMOVE=CMOVZ)
CMOVG	R16,R/M16	P6	CMOVG R16, R/M16	Move r/m16 to r16 if greater (ZF=0 and SF=OF) (CMOVG=CMOVNLE)
CMOVGE	R16,R/M16	P6	CMOVGE R16, R/M16	Move r/m16 to r16 if greater or equal (SF=OF) (CMOVGE=CMOVNL)
CMOVL	R16,R/M16	P6	CMOVL R16, R/M16	Move r/m16 to r16 if less (SF!=OF) (CMOVL=CMOVNGE)
CMOVLE	R16,R/M16	P6	CMOVLE R16, R/M16	Move r/m16 to r16 if less or equal (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)
CMOVNA	R16,R/M16	P6	CMOVNA R16, R/M16	Move r/m16 to r16 if not above (CF=1 or ZF=1) (CMOVBE=CMOVNA)
CMOVNAE	R16,R/M16	P6	CMOVNAE R16, R/M16	Move r/m16 to r16 if not above or equal (CF=1) (CMOVB=CMOVC=CMOVNAE)
CMOVNB	R16,R/M16	P6	CMOVNB R16, R/M16	Move r/m16 to r16 if not below (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVNBE	R16,R/M16	P6	CMOVNBE R16, R/M16	Move r/m16 to r16 if not below or equal (CF=0 and ZF=0) (CMOVA=CMOVNBE)
CMOVNC	R16,R/M16	P6	CMOVNC R16, R/M16	Move r/m16 to r16 if not carry (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVNE	R16,R/M16	P6	CMOVNE R16, R/M16	Move r/m16 to r16 if not equal (ZF=0) (CMOVNE=CMOVNZ)
CMOVNG	R16,R/M16	P6	CMOVNG R16, R/M16	Move r/m16 to r16 if not greater (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)
CMOVNGE	R16,R/M16	P6	CMOVNGE R16, R/M16	Move r/m16 to r16 if not greater or equal (SF!=OF) (CMOVL=CMOVNGE)
CMOVNL	R16,R/M16	P6	CMOVNL R16, R/M16	Move r/m16 to r16 if not less (SF=OF) (CMOVGE=CMOVNL)
CMOVNLE	R16,R/M16	P6	CMOVNLE R16, R/M16	Move r/m16 to r16 if not less or equal (ZF=0 and SF=OF) (CMOVG=CMOVNLE)
CMOVNO	R16,R/M16	P6	CMOVNO R16, R/M16	Move r/m16 to r16 if not overflow (OF=0)
CMOVNP	R16,R/M16	P6	CMOVNP R16, R/M16	Move r/m16 to r16 if not parity (PF=0) (CMOVNP=CMOVPO)
CMOVNS	R16,R/M16	P6	CMOVNS R16, R/M16	Move r/m16 to r16 if not sign (SF=0)
CMOVNZ	R16,R/M16	P6	CMOVNZ R16, R/M16	Move r/m16 to r16 if not zero (ZF=0) (CMOVNE=CMOVNZ)
CMOVO	R16,R/M16	P6	CMOVO R16, R/M16	Move r/m16 to r16 if overflow (OF=1)
CMOVP	R16,R/M16	P6	CMOVP R16, R/M16	Move r/m16 to r16 if parity (PF=1) (CMOVP=CMOVPE)
CMOVPE	R16,R/M16	P6	CMOVPE R16, R/M16	Move r/m16 to r16 if parity even (PF=1) (CMOVP=CMOVPE)
CMOVPO	R16,R/M16	P6	CMOVPO R16, R/M16	Move r/m16 to r16 if parity odd (PF=0) (CMOVNP=CMOVPO)
CMOVS	R16,R/M16	P6	CMOVS R16, R/M16	Move r/m16 to r16 if sign (SF=1)
CMOVZ	R16,R/M16	P6	CMOVZ R16, R/M16	Move r/m16 to r16 if zero (ZF=1) (CMOVE=CMOVZ)
;====================================================================
CMOVA	R32,R/M32	P6	CMOVA R32, R/M32	Move r/M32 to r32 if above (CF=0 and ZF=0) (CMOVA=CMOVNBE)
CMOVAE	R32,R/M32	P6	CMOVAE R32, R/M32	Move r/M32 to r32 if above or equal (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVB	R32,R/M32	P6	CMOVB R32, R/M32	Move r/M32 to r32 if below (CF=1) (CMOVB=CMOVC=CMOVNAE)
CMOVBE	R32,R/M32	P6	CMOVBE R32, R/M32	Move r/M32 to r32 if below or equal (CF=1 or ZF=1) (CMOVBE=CMOVNA)
CMOVE	R32,R/M32	P6	CMOVE R32, R/M32	Move r/M32 to r32 if equal (ZF=1) (CMOVE=CMOVZ)
CMOVG	R32,R/M32	P6	CMOVG R32, R/M32	Move r/M32 to r32 if greater (ZF=0 and SF=OF) (CMOVG=CMOVNLE)
CMOVGE	R32,R/M32	P6	CMOVGE R32, R/M32	Move r/M32 to r32 if greater or equal (SF=OF) (CMOVGE=CMOVNL)
CMOVL	R32,R/M32	P6	CMOVL R32, R/M32	Move r/M32 to r32 if less (SF!=OF) (CMOVL=CMOVNGE)
CMOVLE	R32,R/M32	P6	CMOVLE R32, R/M32	Move r/M32 to r32 if less or equal (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)
CMOVNA	R32,R/M32	P6	CMOVNA R32, R/M32	Move r/M32 to r32 if not above (CF=1 or ZF=1) (CMOVBE=CMOVNA)
CMOVNAE	R32,R/M32	P6	CMOVNAE R32, R/M32	Move r/M32 to r32 if not above or equal (CF=1) (CMOVB=CMOVC=CMOVNAE)
CMOVNB	R32,R/M32	P6	CMOVNB R32, R/M32	Move r/M32 to r32 if not below (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVNBE	R32,R/M32	P6	CMOVNBE R32, R/M32	Move r/M32 to r32 if not below or equal (CF=0 and ZF=0) (CMOVA=CMOVNBE)
CMOVNC	R32,R/M32	P6	CMOVNC R32, R/M32	Move r/M32 to r32 if not carry (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVNE	R32,R/M32	P6	CMOVNE R32, R/M32	Move r/M32 to r32 if not equal (ZF=0) (CMOVNE=CMOVNZ)
CMOVNG	R32,R/M32	P6	CMOVNG R32, R/M32	Move r/M32 to r32 if not greater (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)
CMOVNGE	R32,R/M32	P6	CMOVNGE R32, R/M32	Move r/M32 to r32 if not greater or equal (SF!=OF) (CMOVL=CMOVNGE)
CMOVNL	R32,R/M32	P6	CMOVNL R32, R/M32	Move r/M32 to r32 if not less (SF=OF) (CMOVGE=CMOVNL)
CMOVNLE	R32,R/M32	P6	CMOVNLE R32, R/M32	Move r/M32 to r32 if not less or equal (ZF=0 and SF=OF) (CMOVG=CMOVNLE)
CMOVNO	R32,R/M32	P6	CMOVNO R32, R/M32	Move r/M32 to r32 if not overflow (OF=0)
CMOVNP	R32,R/M32	P6	CMOVNP R32, R/M32	Move r/M32 to r32 if not parity (PF=0) (CMOVNP=CMOVPO)
CMOVNS	R32,R/M32	P6	CMOVNS R32, R/M32	Move r/M32 to r32 if not sign (SF=0)
CMOVNZ	R32,R/M32	P6	CMOVNZ R32, R/M32	Move r/M32 to r32 if not zero (ZF=0) (CMOVNE=CMOVNZ)
CMOVO	R32,R/M32	P6	CMOVO R32, R/M32	Move r/M32 to r32 if overflow (OF=1)
CMOVP	R32,R/M32	P6	CMOVP R32, R/M32	Move r/M32 to r32 if parity (PF=1) (CMOVP=CMOVPE)
CMOVPE	R32,R/M32	P6	CMOVPE R32, R/M32	Move r/M32 to r32 if parity even (PF=1) (CMOVP=CMOVPE)
CMOVPO	R32,R/M32	P6	CMOVPO R32, R/M32	Move r/M32 to r32 if parity odd (PF=0) (CMOVNP=CMOVPO)
CMOVS	R32,R/M32	P6	CMOVS R32, R/M32	Move r/M32 to r32 if sign (SF=1)
CMOVZ	R32,R/M32	P6	CMOVZ R32, R/M32	Move r/M32 to r32 if zero (ZF=1) (CMOVE=CMOVZ)
;====================================================================
CMOVA	R64,R/M64	X64	CMOVA R64, R/M64	Move r/M64 to r64 if above (CF=0 and ZF=0) (CMOVA=CMOVNBE)
CMOVAE	R64,R/M64	X64	CMOVAE R64, R/M64	Move r/M64 to r64 if above or equal (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVB	R64,R/M64	X64	CMOVB R64, R/M64	Move r/M64 to r64 if below (CF=1) (CMOVB=CMOVC=CMOVNAE)
CMOVBE	R64,R/M64	X64	CMOVBE R64, R/M64	Move r/M64 to r64 if below or equal (CF=1 or ZF=1) (CMOVBE=CMOVNA)
CMOVE	R64,R/M64	X64	CMOVE R64, R/M64	Move r/M64 to r64 if equal (ZF=1) (CMOVE=CMOVZ)
CMOVG	R64,R/M64	X64	CMOVG R64, R/M64	Move r/M64 to r64 if greater (ZF=0 and SF=OF) (CMOVG=CMOVNLE)
CMOVGE	R64,R/M64	X64	CMOVGE R64, R/M64	Move r/M64 to r64 if greater or equal (SF=OF) (CMOVGE=CMOVNL)
CMOVL	R64,R/M64	X64	CMOVL R64, R/M64	Move r/M64 to r64 if less (SF!=OF) (CMOVL=CMOVNGE)
CMOVLE	R64,R/M64	X64	CMOVLE R64, R/M64	Move r/M64 to r64 if less or equal (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)
CMOVNA	R64,R/M64	X64	CMOVNA R64, R/M64	Move r/M64 to r64 if not above (CF=1 or ZF=1) (CMOVBE=CMOVNA)
CMOVNAE	R64,R/M64	X64	CMOVNAE R64, R/M64	Move r/M64 to r64 if not above or equal (CF=1) (CMOVB=CMOVC=CMOVNAE)
CMOVNB	R64,R/M64	X64	CMOVNB R64, R/M64	Move r/M64 to r64 if not below (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVNBE	R64,R/M64	X64	CMOVNBE R64, R/M64	Move r/M64 to r64 if not below or equal (CF=0 and ZF=0) (CMOVA=CMOVNBE)
CMOVNC	R64,R/M64	X64	CMOVNC R64, R/M64	Move r/M64 to r64 if not carry (CF=0) (CMOVAE=CMOVNB=CMOVNC)
CMOVNE	R64,R/M64	X64	CMOVNE R64, R/M64	Move r/M64 to r64 if not equal (ZF=0) (CMOVNE=CMOVNZ)
CMOVNG	R64,R/M64	X64	CMOVNG R64, R/M64	Move r/M64 to r64 if not greater (ZF=1 or SF!=OF) (CMOVLE=CMOVNG)
CMOVNGE	R64,R/M64	X64	CMOVNGE R64, R/M64	Move r/M64 to r64 if not greater or equal (SF!=OF) (CMOVL=CMOVNGE)
CMOVNL	R64,R/M64	X64	CMOVNL R64, R/M64	Move r/M64 to r64 if not less (SF=OF) (CMOVGE=CMOVNL)
CMOVNLE	R64,R/M64	X64	CMOVNLE R64, R/M64	Move r/M64 to r64 if not less or equal (ZF=0 and SF=OF) (CMOVG=CMOVNLE)
CMOVNO	R64,R/M64	X64	CMOVNO R64, R/M64	Move r/M64 to r64 if not overflow (OF=0)
CMOVNP	R64,R/M64	X64	CMOVNP R64, R/M64	Move r/M64 to r64 if not parity (PF=0) (CMOVNP=CMOVPO)
CMOVNS	R64,R/M64	X64	CMOVNS R64, R/M64	Move r/M64 to r64 if not sign (SF=0)
CMOVNZ	R64,R/M64	X64	CMOVNZ R64, R/M64	Move r/M64 to r64 if not zero (ZF=0) (CMOVNE=CMOVNZ)
CMOVO	R64,R/M64	X64	CMOVO R64, R/M64	Move r/M64 to r64 if overflow (OF=1)
CMOVP	R64,R/M64	X64	CMOVP R64, R/M64	Move r/M64 to r64 if parity (PF=1) (CMOVP=CMOVPE)
CMOVPE	R64,R/M64	X64	CMOVPE R64, R/M64	Move r/M64 to r64 if parity even (PF=1) (CMOVP=CMOVPE)
CMOVPO	R64,R/M64	X64	CMOVPO R64, R/M64	Move r/M64 to r64 if parity odd (PF=0) (CMOVNP=CMOVPO)
CMOVS	R64,R/M64	X64	CMOVS R64, R/M64	Move r/M64 to r64 if sign (SF=1)
CMOVZ	R64,R/M64	X64	CMOVZ R64, R/M64	Move r/M64 to r64 if zero (ZF=1) (CMOVE=CMOVZ)
;====================================================================
AAA		8086	AAA	ASCII adjust AL after addition.
AAD		8086	AAD	ASCII adjust AX before division.
AAD	IMM8	8086	AAD IMM8	Adjust AX before division to number base imm8.
AAM		8086	AAM	ASCII adjust AX after multiply.
AAM	IMM8	8086	AAM IMM8	Adjust AX after multiply to number base imm8.
AAS		8086	AAS	ASCII adjust AL after subtraction.
;====================================================================
ADC	AL,IMM8	8086	ADC AL,IMM8	Add with CF imm8 to AL.
ADC	AX,IMM16	8086	ADC AX,IMM16	Add with CF imm16 to AX.
ADC	EAX,IMM32	8086	ADC EAX,IMM32	Add with CF imM32 to EAX.
ADC	R/M16,IMM16	8086	ADC R/M16,IMM16	Add with CF imm16 to r/m16.
ADC	R/M16,IMM8	8086	ADC R/M16,IMM8	Add with CF sign-extended imm8 to r/m16.
ADC	R/M16,R16	8086	ADC R/M16,R16	Add with CF r16 to r/m16.
ADC	R/M32,IMM32	386	ADC R/M32,IMM32	Add with CF imM32 to r/M32.
ADC	R/M32,IMM8	386	ADC R/M32,IMM8	Add with CF sign-extended imm8 into r/M32.
ADC	R/M32,R32	386	ADC R/M32,R32	Add with CF r32 to r/M32.
ADC	R/M64,IMM32	X64	ADC R/M64,IMM32	Add with CF imM32 sign extended to 64-bits to r/M64.
ADC	R/M64,IMM8	X64	ADC R/M64,IMM8	Add with CF sign-extended imm8 into r/M64.
ADC	R/M64,R64	X64	ADC R/M64,R64	Add with CF r64 to r/M64.
ADC	R/M8,IMM8	8086	ADC R/M8,IMM8	Add with CF imm8 to r/m8.
ADC	R/M8,R8	8086	ADC R/M8,R8	Add with CF byte register to r/m8.
ADC	R16,R/M16	8086	ADC R16,R/M16	Add with CF r/m16 to r16.
ADC	R32,R/M32	386	ADC R32,R/M32	Add with CF r/M32 to r32.
ADC	R64,R/M64	X64	ADC R64,R/M64	Add with CF r/M64 to r64.
ADC	R8,R/M8	8086	ADC R8,R/M8	Add with CF r/m8 to byte register.
ADC	RAX,IMM32	X64	ADC RAX,IMM32	Add with CF imM32 sign extended to 64-bits to RAX.

ADD	AL,IMM8	8086	ADD AL,IMM8	Add imm8 to AL.
ADD	AX,IMM16	8086	ADD AX,IMM16	Add imm16 to AX.
ADD	EAX,IMM32	386	ADD EAX,IMM32	Add imM32 to EAX.
ADD	R/M16,IMM16	8086	ADD R/M16,IMM16	Add imm16 to r/m16.
ADD	R/M16,IMM8	8086	ADD R/M16,IMM8	Add sign-extended imm8 to r/m16.
ADD	R/M16,R16	8086	ADD R/M16,R16	Add r16 to r/m16.
ADD	R/M32,IMM32	386	ADD R/M32,IMM32	Add imM32 to r/M32.
ADD	R/M32,IMM8	386	ADD R/M32,IMM8	Add sign-extended imm8 to r/M32.
ADD	R/M32,R32	386	ADD R/M32,R32	Add r32 to r/M32.
ADD	R/M64,IMM32	X64	ADD R/M64,IMM32	Add imM32 sign-extended to 64-bits to r/M64.
ADD	R/M64,IMM8	X64	ADD R/M64,IMM8	Add sign-extended imm8 to r/M64.
ADD	R/M64,R64	X64	ADD R/M64,R64	Add r64 to r/M64.
ADD	R/M8,IMM8	8086	ADD R/M8,IMM8	Add imm8 to r/m8.
ADD	R/M8,R8	8086	ADD R/M8,R8	Add r8 to r/m8.
ADD	R16,R/M16	8086	ADD R16,R/M16	Add r/m16 to r16.
ADD	R32,R/M32	386	ADD R32,R/M32	Add r/M32 to r32.
ADD	R64,R/M64	X64	ADD R64,R/M64	Add r/M64 to r64.
ADD	R8,R/M8	8086	ADD R8,R/M8	Add r/m8 to r8.
ADD	RAX,IMM32	8086	ADD RAX,IMM32	Add imM32 sign-extended to 64-bits to RAX.
AND	AL,IMM8	8086	AND AL,IMM8	AL AND imm8.
AND	AX,IMM16	8086	AND AX,IMM16	AX AND imm16.
AND	EAX,IMM32	386	AND EAX,IMM32	EAX AND imM32.
AND	R/M16,IMM16	8086	AND R/M16,IMM16	r/m16 AND imm16.
AND	R/M16,IMM8	8086	AND R/M16,IMM8	r/m16 AND imm8 (sign-extended).
AND	R/M16,R16	8086	AND R/M16,R16	r/m16 AND r16.
AND	R/M32,IMM32	386	AND R/M32,IMM32	r/M32 AND imM32.
AND	R/M32,IMM8	386	AND R/M32,IMM8	r/M32 AND imm8 (sign-extended).
AND	R/M32,R32	386	AND R/M32,R32	r/M32 AND r32.
AND	R/M64,IMM32	X64	AND R/M64,IMM32	r/M64 AND imM32 sign extended to 64-bits.
AND	R/M64,IMM8	X64	AND R/M64,IMM8	r/M64 AND imm8 (sign-extended).
AND	R/M64,R64	X64	AND R/M64,R64	r/M64 AND r32.
AND	R/M8,IMM8	8086	AND R/M8,IMM8	r/m8 AND imm8.
AND	R/M8,R8	8086	AND R/M8,R8	r/m8 AND r8.
AND	R16,R/M16	8086	AND R16,R/M16	r16 AND r/m16.
AND	R32,R/M32	386	AND R32,R/M32	r32 AND r/M32.
AND	R64,R/M64	X64	AND R64,R/M64	r64 AND r/M64.
AND	R8,R/M8	8086	AND R8,R/M8	r8 AND r/m8.
AND	RAX,IMM32	386	AND RAX,IMM32	RAX AND imM32 sign-extended to 64-bits.
ARPL	R/M16,R16	286	ARPL R/M16,R16	Adjust RPL of r/m16 to not less than RPL of r16.
BOUND	R16,M16&16	186	BOUND R16,M16&16	Check if r16 (array index) is within bounds specified by m16&amp;16.
BOUND	R32,M32&32	386	BOUND R32,M32&32	Check if r32 (array index) is within bounds specified by M32&amp;32.
BSF	R16,R/M16	386	BSF R16,R/M16	Bit scan forward on r/m16.
BSF	R32,R/M32	386	BSF R32,R/M32	Bit scan forward on r/M32.
BSF	R64,R/M64	X64	BSF R64,R/M64	Bit scan forward on r/M64.
BSR	R16,R/M16	386	BSR R16,R/M16	Bit scan reverse on r/m16.
BSR	R32,R/M32	386	BSR R32,R/M32	Bit scan reverse on r/M32.
BSR	R64,R/M64	X64	BSR R64,R/M64	Bit scan reverse on r/M64.
BSWAP	R32	486	BSWAP R32	Reverses the byte order of a 32-bit register.
BSWAP	R64	X64	BSWAP R64	Reverses the byte order of a 64-bit register.
BT	R/M16,IMM8	386	BT R/M16,IMM8	Store selected bit in CF flag.
BT	R/M16,R16	386	BT R/M16,R16	Store selected bit in CF flag.
BT	R/M32,IMM8	386	BT R/M32,IMM8	Store selected bit in CF flag.
BT	R/M32,R32	386	BT R/M32,R32	Store selected bit in CF flag.
BT	R/M64,IMM8	X64	BT R/M64,IMM8	Store selected bit in CF flag.
BT	R/M64,R64	X64	BT R/M64,R64	Store selected bit in CF flag.
BTC	R/M16,IMM8	386	BTC R/M16,IMM8	Store selected bit in CF flag and complement.
BTC	R/M16,R16	386	BTC R/M16,R16	Store selected bit in CF flag and complement.
BTC	R/M32,IMM8	386	BTC R/M32,IMM8	Store selected bit in CF flag and complement.
BTC	R/M32,R32	386	BTC R/M32,R32	Store selected bit in CF flag and complement.
BTC	R/M64,IMM8	X64	BTC R/M64,IMM8	Store selected bit in CF flag and complement.
BTC	R/M64,R64	X64	BTC R/M64,R64	Store selected bit in CF flag and complement.
BTR	R/M16,IMM8	386	BTR R/M16,IMM8	Store selected bit in CF flag and clear.
BTR	R/M16,R16	386	BTR R/M16,R16	Store selected bit in CF flag and clear.
BTR	R/M32,IMM8	386	BTR R/M32,IMM8	Store selected bit in CF flag and clear.
BTR	R/M32,R32	386	BTR R/M32,R32	Store selected bit in CF flag and clear.
BTR	R/M64,IMM8	X64	BTR R/M64,IMM8	Store selected bit in CF flag and clear.
BTR	R/M64,R64	X64	BTR R/M64,R64	Store selected bit in CF flag and clear.
BTS	R/M16,IMM8	386	BTS R/M16,IMM8	Store selected bit in CF flag and set.
BTS	R/M16,R16	386	BTS R/M16,R16	Store selected bit in CF flag and set.
BTS	R/M32,IMM8	386	BTS R/M32,IMM8	Store selected bit in CF flag and set.
BTS	R/M32,R32	386	BTS R/M32,R32	Store selected bit in CF flag and set.
BTS	R/M64,IMM8	X64	BTS R/M64,IMM8	Store selected bit in CF flag and set.
BTS	R/M64,R64	X64	BTS R/M64,R64	Store selected bit in CF flag and set.

CALL	M16:16	8086	CALL M16:16	Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction.
CALL	M16:32	386	CALL M16:32	In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.
CALL	M16:64	X64	CALL M16:64	In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction.
CALL	PTR16:16	8086	CALL PTR16:16	Call far, absolute, address given in operand.
CALL	PTR16:32	386	CALL PTR16:32	Call far, absolute, address given in operand.
CALL	R/M16	8086	CALL R/M16	Call near, absolute indirect, address given in r/m16.
CALL	R/M32	386	CALL R/M32	Call near, absolute indirect, address given in r/M32.
CALL	R/M64	X64	CALL R/M64	Call near, absolute indirect, address given in r/M64.
CALL	REL16	8086	CALL REL16	Call near, relative, displacement relative to next instruction.
CALL	REL32	386	CALL REL32	Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.

CBW		8086	CBW	AX ← sign-extend of AL.
CDQ		386	CDQ	EDX:EAX ← sign-extend of EAX.
CDQE		X64	CDQE	RAX ← sign-extend of EAX.
CLAC		486	CLAC	Clear the Alignment Check (AC) flag in the EFLAGS register.
CLC		8086	CLC	Clear CF flag.
CLD		8086	CLD	Clear DF flag.

CLFLUSH	M8	SSE2	CLFLUSH M8	Flushes cache line containing m8.
CLFLUSHOPT	M8	X64	CLFLUSHOPT M8	Flushes cache line containing m8.

CLI		8086	CLI	Clear interrupt flag; interrupts disabled when interrupt flag cleared.
CLTS		286	CLTS	Clears TS flag in CR0.
CMC		8086	CMC	Complement CF flag.

CMP	AL,IMM8	8086	CMP AL,IMM8	Compare imm8 with AL.
CMP	AX,IMM16	8086	CMP AX,IMM16	Compare imm16 with AX.
CMP	EAX,IMM32	386	CMP EAX,IMM32	Compare imM32 with EAX.
CMP	R/M16,IMM16	8086	CMP R/M16,IMM16	Compare imm16 with r/m16.
CMP	R/M16,IMM8	8086	CMP R/M16,IMM8	Compare imm8 with r/m16.
CMP	R/M16,R16	8086	CMP R/M16,R16	Compare r16 with r/m16.
CMP	R/M32,IMM32	386	CMP R/M32,IMM32	Compare imM32 with r/M32.
CMP	R/M32,IMM8	386	CMP R/M32,IMM8	Compare imm8 with r/M32.
CMP	R/M32,R32	386	CMP R/M32,R32	Compare r32 with r/M32.
CMP	R/M64,IMM32	X64	CMP R/M64,IMM32	Compare imM32 sign-extended to 64-bits with r/M64.
CMP	R/M64,IMM8	X64	CMP R/M64,IMM8	Compare imm8 with r/M64.
CMP	R/M64,R64	X64	CMP R/M64,R64	Compare r64 with r/M64.
CMP	R/M8,IMM8	8086	CMP R/M8,IMM8	Compare imm8 with r/m8.
CMP	R/M8,R8	8086	CMP R/M8,R8	Compare r8 with r/m8.
CMP	R16,R/M16	8086	CMP R16,R/M16	Compare r/m16 with r16.
CMP	R32,R/M32	386	CMP R32,R/M32	Compare r/M32 with r32.
CMP	R64,R/M64	X64	CMP R64,R/M64	Compare r/M64 with r64.
CMP	R8,R/M8	8086	CMP R8,R/M8	Compare r/m8 with r8.
CMP	RAX,IMM32	386	CMP RAX,IMM32	Compare imM32 sign-extended to 64-bits with RAX.
CMPS	M16,M16	8086	CMPS M16,M16	For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.
CMPS	M32,M32	386	CMPS M32,M32	For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly.
CMPS	M64,M64	X64	CMPS M64,M64	Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.
CMPS	M8,M8	8086	CMPS M8,M8	For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly.
CMPSB		8086	CMPSB	For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly.
CMPSD		386	CMPSD	For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.
CMPSQ		X64	CMPSQ	Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.
CMPSW		8086	CMPSW	For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.
CMPXCHG	R/M16,R16	PENT	CMPXCHG R/M16,R16	Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.
CMPXCHG	R/M32,R32	PENT	CMPXCHG R/M32,R32	Compare EAX with r/M32. If equal, ZF is set and r32 is loaded into r/M32. Else, clear ZF and load r/M32 into EAX.
CMPXCHG	R/M64,R64	X64	CMPXCHG R/M64,R64	Compare RAX with r/M64. If equal, ZF is set and r64 is loaded into r/M64. Else, clear ZF and load r/M64 into RAX.
CMPXCHG	R/M8,R8	PENT	CMPXCHG R/M8,R8	Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
CMPXCHG16B	M128	X64	CMPXCHG16B M128	Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX.
CMPXCHG8B	M64	PENT	CMPXCHG8B M64	Compare EDX:EAX with M64. If equal, set ZF and load ECX:EBX into M64. Else, clear ZF and load M64 into EDX:EAX.
CPUID		PENT	CPUID	Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
CQO		X64	CQO	RDX:RAX← sign-extend of RAX.

CRC32	R32,R/M16	SSE42	CRC32 R32,R/M16	Accumulate CRC32 on r/m16.
CRC32	R32,R/M32	SSE42	CRC32 R32,R/M32	Accumulate CRC32 on r/M32.
CRC32	R32,R/M8	SSE42	CRC32 R32,R/M8	Accumulate CRC32 on r/m8.
CRC32	R64,R/M64	SSE42	CRC32 R64,R/M64	Accumulate CRC32 on r/M64.
CRC32	R64,R/M8	SSE42	CRC32 R64,R/M8	Accumulate CRC32 on r/m8.

CVTPD2PI	MM,XMM/M128	SSE2	CVTPD2PI MM,XMM/M128	Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm.
CVTPI2PD	XMM,MM/M64	SSE2	CVTPI2PD XMM,MM/M64	Convert two packed signed doubleword integers from mm/meM64 to two packed double-precision floating-point values in xmm.
CVTPI2PS	XMM,MM/M64	SSE2	CVTPI2PS XMM,MM/M64	Convert two signed doubleword integers from mm/M64 to two single-precision floating-point values in xmm.
CVTPS2PI	MM,XMM/M64	SSE2	CVTPS2PI MM,XMM/M64	Convert two packed single-precision floating-point values from xmm/M64 to two packed signed doubleword integers in mm.
CVTTPD2PI	MM,XMM/M128	SSE2	CVTTPD2PI MM,XMM/M128	Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.
CVTTPS2PI	MM,XMM/M64	SSE2	CVTTPS2PI MM,XMM/M64	Convert two single-precision floating-point values from xmm/M64 to two signed doubleword signed integers in mm using truncation.

CWD		8086	CWD	DX:AX ← sign-extend of AX.
CWDE		386	CWDE	EAX ← sign-extend of AX.
DAA		8086	DAA	Decimal adjust AL after addition.
DAS		8086	DAS	Decimal adjust AL after subtraction.
DEC	R/M16	8086	DEC R/M16	Decrement r/m16 by 1.
DEC	R/M32	386	DEC R/M32	Decrement r/M32 by 1.
DEC	R/M64	X64	DEC R/M64	Decrement r/M64 by 1.
DEC	R/M8	8086	DEC R/M8	Decrement r/m8 by 1.
DEC	R16	8086	DEC R16	Decrement r16 by 1.
DEC	R32	386	DEC R32	Decrement r32 by 1.

DIV	R/M16	8086	DIV R/M16	Unsigned divide DX:AX by r/m16, with result stored in AX ← Quotient, DX ← Remainder.
DIV	R/M32	386	DIV R/M32	Unsigned divide EDX:EAX by r/M32, with result stored in EAX ← Quotient, EDX ← Remainder.
DIV	R/M64	X64	DIV R/M64	Unsigned divide RDX:RAX by r/M64, with result stored in RAX ← Quotient, RDX ← Remainder.
DIV	R/M8	8086	DIV R/M8	Unsigned divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder.
EMMS		PENT	EMMS	Set the x87 FPU tag word to empty.
ENTER	IMM16,0	186	ENTER IMM16,0	Create a stack frame for a procedure.
ENTER	IMM16,1	186	ENTER IMM16,1	Create a stack frame with a nested pointer for a procedure.
ENTER	IMM16,IMM8	186	ENTER IMM16,IMM8	Create a stack frame with nested pointers for a procedure.
F2XM1		8086	F2XM1	Replace ST(0) with (2ST(0) – 1).
FABS		8086	FABS	Replace ST with its absolute value.
FADD	M32FP	8086	FADD M32FP	Add M32fp to ST(0) and store result in ST(0).
FADD	M64FP	8086	FADD M64FP	Add M64fp to ST(0) and store result in ST(0).
FADD	ST(0),ST(I)	8086	FADD ST(0),ST(I)	Add ST(0) to ST(i) and store result in ST(0).
FADD	ST(I),ST(0)	8086	FADD ST(I),ST(0)	Add ST(i) to ST(0) and store result in ST(i).
FADDP		8086	FADDP	Add ST(0) to ST(1), store result in ST(1), and pop the register stack.
FADDP	ST(I),ST(0)	8086	FADDP ST(I),ST(0)	Add ST(0) to ST(i), store result in ST(i), and pop the register stack.
FBLD	M80DEC	8086	FBLD M80DEC	Convert BCD value to floating-point and push onto the FPU stack.
FBSTP	M80BCD	8086	FBSTP M80BCD	Store ST(0) in m80bcd and pop ST(0).
FCHS		8086	FCHS	Complements sign of ST(0).
FCLEX		8086	FCLEX	Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.
FCMOVB	ST(0),ST(I)	P6	FCMOVB ST(0),ST(I)	Move if below (CF=1).
FCMOVBE	ST(0),ST(I)	P6	FCMOVBE ST(0),ST(I)	Move if below or equal (CF=1 or ZF=1).
FCMOVE	ST(0),ST(I)	P6	FCMOVE ST(0),ST(I)	Move if equal (ZF=1).
FCMOVNB	ST(0),ST(I)	P6	FCMOVNB ST(0),ST(I)	Move if not below (CF=0).
FCMOVNBE	ST(0),ST(I)	P6	FCMOVNBE ST(0),ST(I)	Move if not below or equal (CF=0 and ZF=0).
FCMOVNE	ST(0),ST(I)	P6	FCMOVNE ST(0),ST(I)	Move if not equal (ZF=0).
FCMOVU	ST(0),ST(I)	P6	FCMOVU ST(0),ST(I)	Move if unordered (PF=1).
FCOM		8086	FCOM	Compare ST(0) with ST(1).
FCOM	M32FP	8086	FCOM M32FP	Compare ST(0) with M32fp.
FCOM	M64FP	8086	FCOM M64FP	Compare ST(0) with M64fp.
FCOM	ST(I)	8086	FCOM ST(I)	Compare ST(0) with ST(i).
FCOMI	ST,ST(I)	P6	FCOMI ST,ST(I)	Compare ST(0) with ST(i) and set status flags accordingly.
FCOMIP	ST,ST(I)	P6	FCOMIP ST,ST(I)	Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.
FCOMP		8086	FCOMP	Compare ST(0) with ST(1) and pop register stack.
FCOMP	M32FP	8086	FCOMP M32FP	Compare ST(0) with M32fp and pop register stack.
FCOMP	M64FP	8086	FCOMP M64FP	Compare ST(0) with M64fp and pop register stack.
FCOMP	ST(I)	8086	FCOMP ST(I)	Compare ST(0) with ST(i) and pop register stack.
FCOMPP		8086	FCOMPP	Compare ST(0) with ST(1) and pop register stack twice.
FCOS		386	FCOS	Replace ST(0) with its approximate cosine.
FDECSTP		8086	FDECSTP	Decrement TOP field in FPU status word.
FDIV	M32FP	8086	FDIV M32FP	Divide ST(0) by M32fp and store result in ST(0).
FDIV	M64FP	8086	FDIV M64FP	Divide ST(0) by M64fp and store result in ST(0).
FDIV	ST(0),ST(I)	8086	FDIV ST(0),ST(I)	Divide ST(0) by ST(i) and store result in ST(0).
FDIV	ST(I),ST(0)	8086	FDIV ST(I),ST(0)	Divide ST(i) by ST(0) and store result in ST(i).
FDIVP		8086	FDIVP	Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.
FDIVP	ST(I),ST(0)	8086	FDIVP ST(I),ST(0)	Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.
FDIVR	M32FP	8086	FDIVR M32FP	Divide M32fp by ST(0) and store result in ST(0).
FDIVR	M64FP	8086	FDIVR M64FP	Divide M64fp by ST(0) and store result in ST(0).
FDIVR	ST(0),ST(I)	8086	FDIVR ST(0),ST(I)	Divide ST(i) by ST(0) and store result in ST(0).
FDIVR	ST(I),ST(0)	8086	FDIVR ST(I),ST(0)	Divide ST(0) by ST(i) and store result in ST(i).
FDIVRP		8086	FDIVRP	Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.
FDIVRP	ST(I),ST(0)	8086	FDIVRP ST(I),ST(0)	Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.
FFREE	ST(I)	8086	FFREE ST(I)	Sets tag for ST(i) to empty.
FIADD	M16INT	8086	FIADD M16INT	Add m16int to ST(0) and store result in ST(0).
FIADD	M32INT	8086	FIADD M32INT	Add M32int to ST(0) and store result in ST(0).
FICOM	M16INT	8086	FICOM M16INT	Compare ST(0) with m16int.
FICOM	M32INT	8086	FICOM M32INT	Compare ST(0) with M32int.
FICOMP	M16INT	8086	FICOMP M16INT	Compare ST(0) with m16int and pop stack register.
FICOMP	M32INT	8086	FICOMP M32INT	Compare ST(0) with M32int and pop stack register.
FIDIV	M16INT	8086	FIDIV M16INT	Divide ST(0) by m16int and store result in ST(0).
FIDIV	M32INT	8086	FIDIV M32INT	Divide ST(0) by M32int and store result in ST(0).
FIDIVR	M16INT	8086	FIDIVR M16INT	Divide m16int by ST(0) and store result in ST(0).
FIDIVR	M32INT	8086	FIDIVR M32INT	Divide M32int by ST(0) and store result in ST(0).
FILD	M16INT	8086	FILD M16INT	Push m16int onto the FPU register stack.
FILD	M32INT	8086	FILD M32INT	Push M32int onto the FPU register stack.
FILD	M64INT	8086	FILD M64INT	Push M64int onto the FPU register stack.
FIMUL	M16INT	8086	FIMUL M16INT	Multiply ST(0) by m16int and store result in ST(0).
FIMUL	M32INT	8086	FIMUL M32INT	Multiply ST(0) by M32int and store result in ST(0).
FINCSTP		8086	FINCSTP	Increment the TOP field in the FPU status register.
FINIT		8086	FINIT	Initialize FPU after checking for pending unmasked floating-point exceptions.
FIST	M16INT	8086	FIST M16INT	Store ST(0) in m16int.
FIST	M32INT	8086	FIST M32INT	Store ST(0) in M32int.
FISTP	M16INT	8086	FISTP M16INT	Store ST(0) in m16int and pop register stack.
FISTP	M32INT	8086	FISTP M32INT	Store ST(0) in M32int and pop register stack.
FISTP	M64INT	8086	FISTP M64INT	Store ST(0) in M64int and pop register stack.
FISTTP	M16INT	SSE3	FISTTP M16INT	Store ST(0) in m16int with truncation.
FISTTP	M32INT	SSE3	FISTTP M32INT	Store ST(0) in M32int with truncation.
FISTTP	M64INT	SSE3	FISTTP M64INT	Store ST(0) in M64int with truncation.
FISUB	M16INT	8086	FISUB M16INT	Subtract m16int from ST(0) and store result in ST(0).
FISUB	M32INT	8086	FISUB M32INT	Subtract M32int from ST(0) and store result in ST(0).
FISUBR	M16INT	8086	FISUBR M16INT	Subtract ST(0) from m16int and store result in ST(0).
FISUBR	M32INT	8086	FISUBR M32INT	Subtract ST(0) from M32int and store result in ST(0).
FLD	M32FP	8086	FLD M32FP	Push M32fp onto the FPU register stack.
FLD	M64FP	8086	FLD M64FP	Push M64fp onto the FPU register stack.
FLD	M80FP	8086	FLD M80FP	Push m80fp onto the FPU register stack.
FLD	ST(I)	8086	FLD ST(I)	Push ST(i) onto the FPU register stack.
FLD1		8086	FLD1	Push +1.0 onto the FPU register stack.
FLDCW	M2BYTE	8086	FLDCW M2BYTE	Load FPU control word from m2byte.
FLDENV	M14/28BYTE	8086	FLDENV M14/28BYTE	Load FPU environment from m14byte or m28byte.
FLDL2E		8086	FLDL2E	Push log2e onto the FPU register stack.
FLDL2T		8086	FLDL2T	Push log210 onto the FPU register stack.
FLDLG2		8086	FLDLG2	Push log102 onto the FPU register stack.
FLDLN2		8086	FLDLN2	Push loge2 onto the FPU register stack.
FLDPI		8086	FLDPI	Push π onto the FPU register stack.
FLDZ		8086	FLDZ	Push +0.0 onto the FPU register stack.
FMUL	M32FP	8086	FMUL M32FP	Multiply ST(0) by M32fp and store result in ST(0).
FMUL	M64FP	8086	FMUL M64FP	Multiply ST(0) by M64fp and store result in ST(0).
FMUL	ST(0),ST(I)	8086	FMUL ST(0),ST(I)	Multiply ST(0) by ST(i) and store result in ST(0).
FMUL	ST(I),ST(0)	8086	FMUL ST(I),ST(0)	Multiply ST(i) by ST(0) and store result in ST(i).
FMULP		8086	FMULP	Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack.
FMULP	ST(I),ST(0)	8086	FMULP ST(I),ST(0)	Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.
FNCLEX		8086	FNCLEX	Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.
FNINIT		8086	FNINIT	Initialize FPU without checking for pending unmasked floating-point exceptions.
FNOP		8086	FNOP	No operation is performed.
FNSAVE	M94/108BYTE	8086	FNSAVE M94/108BYTE	Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.
FNSTCW	M2BYTE	8086	FNSTCW M2BYTE	Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.
FNSTENV	M14/28BYTE	8086	FNSTENV M14/28BYTE	Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.
FNSTSW	AX	286	FNSTSW AX	Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.
FNSTSW	M2BYTE	8086	FNSTSW M2BYTE	Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.
FPATAN		286	FPATAN	Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.
FPREM		286	FPREM	Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).
FPREM1		386	FPREM1	Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).
FPTAN		8086	FPTAN	Replace ST(0) with its approximate tangent and push 1 onto the FPU stack.
FRNDINT		8086	FRNDINT	Round ST(0) to an integer.
FRSTOR	M94/108BYTE	8086	FRSTOR M94/108BYTE	Load FPU state from m94byte or m108byte.
FSAVE	M94/108BYTE	8086	FSAVE M94/108BYTE	Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.
FSCALE		8086	FSCALE	Scale ST(0) by ST(1).
FSIN		386	FSIN	Replace ST(0) with the approximate of its sine.
FSINCOS		386	FSINCOS	Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack.
FSQRT		8086	FSQRT	Computes square root of ST(0) and stores the result in ST(0).
FST	M32FP	8086	FST M32FP	Copy ST(0) to M32fp.
FST	M64FP	8086	FST M64FP	Copy ST(0) to M64fp.
FST	ST(I)	8086	FST ST(I)	Copy ST(0) to ST(i).
FSTCW	M2BYTE	8086	FSTCW M2BYTE	Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.
FSTENV	M14/28BYTE	8086	FSTENV M14/28BYTE	Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.
FSTP	M32FP	8086	FSTP M32FP	Copy ST(0) to M32fp and pop register stack.
FSTP	M64FP	8086	FSTP M64FP	Copy ST(0) to M64fp and pop register stack.
FSTP	M80FP	8086	FSTP M80FP	Copy ST(0) to m80fp and pop register stack.
FSTP	ST(I)	8086	FSTP ST(I)	Copy ST(0) to ST(i) and pop register stack.
FSTSW	AX	286	FSTSW AX	Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.
FSTSW	M2BYTE	8086	FSTSW M2BYTE	Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.
FSUB	M32FP	8086	FSUB M32FP	Subtract M32fp from ST(0) and store result in ST(0).
FSUB	M64FP	8086	FSUB M64FP	Subtract M64fp from ST(0) and store result in ST(0).
FSUB	ST(0),ST(I)	8086	FSUB ST(0),ST(I)	Subtract ST(i) from ST(0) and store result in ST(0).
FSUB	ST(I),ST(0)	8086	FSUB ST(I),ST(0)	Subtract ST(0) from ST(i) and store result in ST(i).
FSUBP		8086	FSUBP	Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.
FSUBP	ST(I),ST(0)	8086	FSUBP ST(I),ST(0)	Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.
FSUBR	M32FP	8086	FSUBR M32FP	Subtract ST(0) from M32fp and store result in ST(0).
FSUBR	M64FP	8086	FSUBR M64FP	Subtract ST(0) from M64fp and store result in ST(0).
FSUBR	ST(0),ST(I)	8086	FSUBR ST(0),ST(I)	Subtract ST(0) from ST(i) and store result in ST(0).
FSUBR	ST(I),ST(0)	8086	FSUBR ST(I),ST(0)	Subtract ST(i) from ST(0) and store result in ST(i).
FSUBRP		8086	FSUBRP	Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.
FSUBRP	ST(I),ST(0)	8086	FSUBRP ST(I),ST(0)	Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.
FTST		8086	FTST	Compare ST(0) with 0.0.
FUCOM		386	FUCOM	Compare ST(0) with ST(1).
FUCOM	ST(I)	386	FUCOM ST(I)	Compare ST(0) with ST(i).
FUCOMI	ST,ST(I)	P6	FUCOMI ST,ST(I)	Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.
FUCOMIP	ST,ST(I)	P6	FUCOMIP ST,ST(I)	Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.
FUCOMP		386	FUCOMP	Compare ST(0) with ST(1) and pop register stack.
FUCOMP	ST(I)	386	FUCOMP ST(I)	Compare ST(0) with ST(i) and pop register stack.
FUCOMPP		386	FUCOMPP	Compare ST(0) with ST(1) and pop register stack twice.

FXAM		8086	FXAM	Classify value or number in ST(0).
FXCH		8086	FXCH	Exchange the contents of ST(0) and ST(1).
FXCH	ST(I)	8086	FXCH ST(I)	Exchange the contents of ST(0) and ST(i).
FXRSTOR	M512BYTE	SSE3	FXRSTOR M512BYTE	Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.
FXSAVE	M512BYTE	SSE3	FXSAVE M512BYTE	Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
FXTRACT		8086	FXTRACT	Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.
FYL2X		8086	FYL2X	Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the register stack.
FYL2XP1		8086	FYL2XP1	Replace ST(1) with ST(1) ∗ log2(ST(0) + 1.0) and pop the register stack.
HLT		8086	HLT	Halt
IDIV	R/M16	8086	IDIV R/M16	Signed divide DX:AX by r/m16, with result stored in AX ← Quotient, DX ← Remainder.
IDIV	R/M32	386	IDIV R/M32	Signed divide EDX:EAX by r/M32, with result stored in EAX ← Quotient, EDX ← Remainder.
IDIV	R/M64	X64	IDIV R/M64	Signed divide RDX:RAX by r/M64, with result stored in RAX ← Quotient, RDX ← Remainder.
IDIV	R/M8	8086	IDIV R/M8	Signed divide AX by r/m8, with result stored in: AL ← Quotient, AH ← Remainder.
IMUL	R/M16	8086	IMUL R/M16	DX:AX ← AX ∗ r/m word.
IMUL	R/M32	386	IMUL R/M32	EDX:EAX ← EAX ∗ r/M32.
IMUL	R/M64	X64	IMUL R/M64	RDX:RAX ← RAX ∗ r/M64.
IMUL	R/M8	8086	IMUL R/M8	AX← AL ∗ r/m byte.
IMUL	R16,R/M16	8086	IMUL R16,R/M16	word register ← word register ∗ r/m16.
IMUL	R16,R/M16,IMM16	8086	IMUL R16,R/M16,IMM16	word register ← r/m16 ∗ immediate word.
IMUL	R16,R/M16,IMM8	8086	IMUL R16,R/M16,IMM8	word register ← r/m16 ∗ sign-extended immediate byte.
IMUL	R32,R/M32	386	IMUL R32,R/M32	doubleword register ← doubleword register ∗ r/M32.
IMUL	R32,R/M32,IMM32	386	IMUL R32,R/M32,IMM32	doubleword register ← r/M32 ∗ immediate doubleword.
IMUL	R32,R/M32,IMM8	386	IMUL R32,R/M32,IMM8	doubleword register ← r/M32 ∗ sign-extended immediate byte.
IMUL	R64,R/M64	X64	IMUL R64,R/M64	Quadword register ← Quadword register ∗ r/M64.
IMUL	R64,R/M64,IMM32	X64	IMUL R64,R/M64,IMM32	Quadword register ← r/M64 ∗ immediate doubleword.
IMUL	R64,R/M64,IMM8	X64	IMUL R64,R/M64,IMM8	Quadword register ← r/M64 ∗ sign-extended immediate byte.
IN	AL,DX	8086	IN AL,DX	Input byte from I/O port in DX into AL.
IN	AL,IMM8	8086	IN AL,IMM8	Input byte from imm8 I/O port address into AL.
IN	AX,DX	8086	IN AX,DX	Input word from I/O port in DX into AX.
IN	AX,IMM8	8086	IN AX,IMM8	Input word from imm8 I/O port address into AX.
IN	EAX,DX	386	IN EAX,DX	Input doubleword from I/O port in DX into EAX.
IN	EAX,IMM8	386	IN EAX,IMM8	Input dword from imm8 I/O port address into EAX.
INC	R/M16	8086	INC R/M16	Increment r/m word by 1.
INC	R/M32	386	INC R/M32	Increment r/m doubleword by 1.
INC	R/M64	X64	INC R/M64	Increment r/m quadword by 1.
INC	R/M8	8086	INC R/M8	Increment r/m byte by 1.
INC	R16	8086	INC R16	Increment word register by 1.
INC	R32	386	INC R32	Increment doubleword register by 1.

INS	M8,DX	8086	INS M8,DX	Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
INS	M16,DX	8086	INS M16,DX	Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1
INS	M32,DX	386	INS M32,DX	Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1

INSB		186	INSB	Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1
INSD		386	INSD	Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1
INSW		186	INSW	Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1
INTO		8086	INTO	Interrupt 4—if overflow flag is 1.
INVD		486	INVD	Flush internal caches; initiate flushing of external caches.
INVLPG	MEM	486	INVLPG MEM	Invalidate Translation Lookaside Buffer (TLB) entries for page containing mem.

IRET		8086	IRET	Interrupt return (16-bit operand size).
IRETD		386	IRETD	Interrupt return (32-bit operand size).

LAHF		8086	LAHF	Load: AH ← EFLAGS(SF:ZF:0:AF:0:PF:1:CF).
LAR	R16,R16/M16	286	LAR R16,R16/M16	r16 ← access rights referenced by r16/m16
LAR	REG,R32/M16	386	LAR REG,R32/M16	reg ← access rights referenced by r32/m16



LDS	R16,M16:16	8086	LDS R16,M16:16	Load DS:r16 with far pointer from memory.
LDS	R32,M16:32	386	LDS R32,M16:32	Load DS:r32 with far pointer from memory.
LEA	R16,MEM	8086	LEA R16,MEM	Store effective address for mem in register r16.
LEA	R32,MEM	386	LEA R32,MEM	Store effective address for mem in register r32.
LEA	R64,MEM	X64	LEA R64,MEM	Store effective address for mem in register r64.
LEAVE		186	LEAVE	Set SP to BP, then pop BP.
LES	R16,M16:16	8086	LES R16,M16:16	Load ES:r16 with far pointer from memory.
LES	R32,M16:32	386	LES R32,M16:32	Load ES:r32 with far pointer from memory.
LFENCE		SSE2	LFENCE	Serializes load operations.
LFS	R16,M16:16	386	LFS R16,M16:16	Load FS:r16 with far pointer from memory.
LFS	R32,M16:32	386	LFS R32,M16:32	Load FS:r32 with far pointer from memory.
LFS	R64,M16:64	X64	LFS R64,M16:64	Load FS:r64 with far pointer from memory.
LGDT	M16&32	286	LGDT M16&32	Load mem into Global Descriptor Table Register (GDTR).
LGDT	M16&64	X64	LGDT M16&64	Load mem into Global Descriptor Table Register (GDTR).
LGS	R16,M16:16	386	LGS R16,M16:16	Load GS:r16 with far pointer from memory.
LGS	R32,M16:32	386	LGS R32,M16:32	Load GS:r32 with far pointer from memory.
LGS	R64,M16:64	X64	LGS R64,M16:64	Load GS:r64 with far pointer from memory.
LIDT	M16&32	386	LIDT M16&32	Load m into Interrupt Descriptor Table Register (IDTR).
LIDT	M16&64	X64	LIDT M16&64	Load m into Interrupt Descriptor Table Register (IDTR).
LLDT	R/M16	286	LLDT R/M16	Load segment selector r/m16 into LDTR.
LMSW	R/M16	286	LMSW R/M16	Loads r/m16 in machine status word of CR0.

LOCK		8086	LOCK	Asserts LOCK# signal for duration of the accompanying instruction.
LODS	M8	8086	LODS M8	For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.
LODS	M16	8086	LODS M16	For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.
LODS	M32	386	LODS M32	For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.
LODS	M64	X64	LODS M64	Load qword at address (R)SI into RAX.

LODSB		8086	LODSB	For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.
LODSW		8086	LODSW	For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.
LODSD		386	LODSD	For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.
LODSQ		X64	LODSQ	Load qword at address (R)SI into RAX.

LOOP	REL8	8086	LOOP REL8	Decrement CX; jump short if CX!=0.
LOOP	REL8,CX	8086	LOOP REL8,CX	Decrement CX; jump short if CX!=0.
LOOP	REL8,ECX	386	LOOP REL8,ECX	Decrement ECX; jump short if ECX!=0.
LOOP	REL8,RCX	X64	LOOP REL8,RCX	Decrement RCX; jump short if RCX!=0.

LOOPE	REL8	8086	LOOPE REL8	Decrement CX; jump short if CX ≠ 0 and ZF = 1.
LOOPE	REL8,CX	8086	LOOPE REL8,CX	Decrement CX; jump short if CX ≠ 0 and ZF = 1.
LOOPE	REL8,ECX	386	LOOPE REL8,ECX	Decrement ECX; jump short if ECX ≠ 0 and ZF = 1.
LOOPE	REL8,RCX	X64	LOOPE REL8,RCX	Decrement RCX; jump short if RCX ≠ 0 and ZF = 1.

LOOPZ	REL8	8086	LOOPE REL8	Decrement CX; jump short if CX ≠ 0 and ZF = 1.
LOOPZ	REL8,CX	8086	LOOPE REL8,CX	Decrement CX; jump short if CX ≠ 0 and ZF = 1.
LOOPZ	REL8,ECX	386	LOOPE REL8,ECX	Decrement ECX; jump short if ECX ≠ 0 and ZF = 1.
LOOPZ	REL8,RCX	X64	LOOPE REL8,RCX	Decrement RCX; jump short if RCX ≠ 0 and ZF = 1.

LOOPNE	REL8	8086	LOOPNE REL8	Decrement CX; jump short if CX ≠ 0 and ZF = 0.
LOOPNE	REL8,CX	8086	LOOPNE REL8,CX	Decrement CX; jump short if CX ≠ 0 and ZF = 0.
LOOPNE	REL8,ECX	386	LOOPNE REL8,ECX	Decrement ECX; jump short if ECX ≠ 0 and ZF = 0.
LOOPNE	REL8,RCX	X64	LOOPNE REL8,RCX	Decrement RCX; jump short if RCX ≠ 0 and ZF = 0.

LOOPNZ	REL8	8086	LOOPNE REL8	Decrement CX; jump short if CX ≠ 0 and ZF = 0.
LOOPNZ	REL8,CX	8086	LOOPNE REL8,CX	Decrement CX; jump short if CX ≠ 0 and ZF = 0.
LOOPNZ	REL8,ECX	386	LOOPNE REL8,ECX	Decrement ECX; jump short if ECX ≠ 0 and ZF = 0.
LOOPNZ	REL8,RCX	X64	LOOPNE REL8,RCX	Decrement RCX; jump short if RCX ≠ 0 and ZF = 0.

LSL	R16,R16/M16	286	LSL R16,R16/M16	Load: r16 ← segment limit, selector r16/m16.
LSL	R32,R32/M16	386	LSL R32,R32/M16	Load: r32 ← segment limit, selector r32/m16.
LSL	R64,R32/M16	X64	LSL R64,R32/M16	Load: r64 ← segment limit, selector r32/m16
LSS	R16,M16:16	286	LSS R16,M16:16	Load SS:r16 with far pointer from memory.
LSS	R32,M16:32	386	LSS R32,M16:32	Load SS:r32 with far pointer from memory.
LSS	R64,M16:64	X64	LSS R64,M16:64	Load SS:r64 with far pointer from memory.
LTR	R/M16	286	LTR R/M16	Load r/m16 into task register.

MASKMOVQ	MM,MM	MMX	MASKMOVQ MM1,MM2	Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI.

MFENCE		SSE2	MFENCE	Serializes load and store operations.
MONITOR		SSE3	MONITOR	Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is DS:EAX (DS:RAX in 64-bit mode).

MOV	AL,MOFFS8	8086	MOV AL,MOFFS8	Move byte at (seg:offset) to AL.
MOV	AX,MOFFS16	8086	MOV AX,MOFFS16	Move word at (seg:offset) to AX.
MOV	EAX,MOFFS32	386	MOV EAX,MOFFS32	Move doubleword at (seg:offset) to EAX.
MOV	MOFFS16,AX	8086	MOV MOFFS16,AX	Move AX to (seg:offset).
MOV	MOFFS32,EAX	386	MOV MOFFS32,EAX	Move EAX to (seg:offset).
MOV	MOFFS64,RAX	X64	MOV MOFFS64,RAX	Move RAX to (offset).
MOV	MOFFS8,AL	8086	MOV MOFFS8,AL	Move AL to (seg:offset).
MOV	R/M16,IMM16	8086	MOV R/M16,IMM16	Move imm16 to r/m16.
MOV	R/M16,R16	8086	MOV R/M16,R16	Move r16 to r/m16.
MOV	R/M16,SREG	8086	MOV R/M16,SREG	Move segment register to r/m16.
MOV	R/M32,IMM32	386	MOV R/M32,IMM32	Move imM32 to r/M32.
MOV	R/M32,R32	386	MOV R/M32,R32	Move r32 to r/M32.
MOV	R/M64,IMM32	X64	MOV R/M64,IMM32	Move imM32 sign extended to 64-bits to r/M64.
MOV	R/M64,R64	X64	MOV R/M64,R64	Move r64 to r/M64.
MOV	R/M64,SREG	X64	MOV R/M64,SREG	Move zero extended 16-bit segment register to r/M64.
MOV	R/M8,IMM8	8086	MOV R/M8,IMM8	Move imm8 to r/m8.
MOV	R/M8,R8	8086	MOV R/M8,R8	Move r8 to r/m8.
MOV	R16,IMM16	8086	MOV R16,IMM16	Move imm16 to r16.
MOV	R16,R/M16	8086	MOV R16,R/M16	Move r/m16 to r16.
MOV	R32,IMM32	386	MOV R32,IMM32	Move imM32 to r32.
MOV	R32,R/M32	386	MOV R32,R/M32	Move r/M32 to r32.
MOV	R64,IMM64	X64	MOV R64,IMM64	Move imM64 to r64.
MOV	R64,R/M64	X64	MOV R64,R/M64	Move r/M64 to r64.
MOV	R8,IMM8	8086	MOV R8,IMM8	Move imm8 to r8.
MOV	R8,R/M8	8086	MOV R8,R/M8	Move r/m8 to r8.
MOV	RAX,MOFFS64	X64	MOV RAX,MOFFS64	Move quadword at (offset) to RAX.
MOV	SREG,R/M16	8086	MOV SREG,R/M16	Move r/m16 to segment register.
MOV	SREG,R/M64	X64	MOV SREG,R/M64	Move lower 16 bits of r/M64 to segment register.

MOVBE	M16,R16	SSE42	MOVBE M16,R16	Reverse byte order in r16 and move to m16.
MOVBE	M32,R32	SSE42	MOVBE M32,R32	Reverse byte order in r32 and move to M32.
MOVBE	M64,R64	SSE42	MOVBE M64,R64	Reverse byte order in r64 and move to M64.
MOVBE	R16,M16	SSE42	MOVBE R16,M16	Reverse byte order in m16 and move to r16.
MOVBE	R32,M32	SSE42	MOVBE R32,M32	Reverse byte order in M32 and move to r32.
MOVBE	R64,M64	SSE42	MOVBE R64,M64	Reverse byte order in M64 and move to r64.

MOVDQ2Q	MM,XMM	SSE2	MOVDQ2Q MM,XMM	Move low quadword from xmm to mmx register.
MOVQ2DQ	XMM,MM	SSE2	MOVQ2DQ XMM,MM	Move quadword from mmx to low quadword of xmm.
MOVNTI	M32,R32	MMX	MOVNTI M32,R32	Move doubleword from r32 to M32 using non-temporal hint.
MOVNTI	M64,R64	X64	MOVNTI M64,R64	Move quadword from r64 to M64 using non-temporal hint.
MOVNTQ	M64,MM	MMX	MOVNTQ M64,MM	Move quadword from mm to M64 using non-temporal hint.

MOVS	M8,M8	8086	MOVS M8,M8	For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.
MOVS	M16,M16	8086	MOVS M16,M16	For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.
MOVS	M32,M32	386	MOVS M32,M32	For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
MOVS	M64,M64	X64	MOVS M64,M64	Move qword from address (R|E)SI to (R|E)DI.

MOVSB		8086	MOVSB	For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.
MOVSD		386	MOVSD	For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
MOVSQ		X64	MOVSQ	Move qword from address (R|E)SI to (R|E)DI.
MOVSW		8086	MOVSW	For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.
MOVSX	R16,R/M8	386	MOVSX R16,R/M8	Move byte to word with sign-extension.
MOVSX	R32,R/M16	386	MOVSX R32,R/M16	Move word to doubleword, with sign-extension.
MOVSX	R32,R/M8	386	MOVSX R32,R/M8	Move byte to doubleword with sign-extension.
MOVSX	R64,R/M16	X64	MOVSX R64,R/M16	Move word to quadword with sign-extension.
MOVSX	R64,R/M8	X64	MOVSX R64,R/M8	Move byte to quadword with sign-extension.
MOVSXD	R64,R/M32	X64	MOVSXD R64,R/M32	Move doubleword to quadword with sign-extension.
MOVZX	R16,R/M8	386	MOVZX R16,R/M8	Move byte to word with zero-extension.
MOVZX	R32,R/M16	386	MOVZX R32,R/M16	Move word to doubleword, zero-extension.
MOVZX	R32,R/M8	386	MOVZX R32,R/M8	Move byte to doubleword, zero-extension.
MOVZX	R64,R/M16	X64	MOVZX R64,R/M16	Move word to quadword, zero-extension.
MOVZX	R64,R/M8	X64	MOVZX R64,R/M8	Move byte to quadword, zero-extension.

MUL	R/M16	8086	MUL R/M16	Unsigned multiply (DX:AX ← AX ∗ r/m16).
MUL	R/M32	386	MUL R/M32	Unsigned multiply (EDX:EAX ← EAX ∗ r/M32).
MUL	R/M64	X64	MUL R/M64	Unsigned multiply (RDX:RAX ← RAX ∗ r/M64).
MUL	R/M8	8086	MUL R/M8	Unsigned multiply (AX ← AL ∗ r/m8).
MWAIT		SSE3	MWAIT	A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.
NEG	R/M16	8086	NEG R/M16	Two's complement negate r/m16.
NEG	R/M32	386	NEG R/M32	Two's complement negate r/M32.
NEG	R/M64	X64	NEG R/M64	Two's complement negate r/M64.
NEG	R/M8	8086	NEG R/M8	Two's complement negate r/m8.
NOP		8086	NOP	One byte no-operation instruction.
NOP	R/M16	8086	NOP R/M16	Multi-byte no-operation instruction.
NOP	R/M32	386	NOP R/M32	Multi-byte no-operation instruction.
NOT	R/M16	8086	NOT R/M16	Reverse each bit of r/m16.
NOT	R/M32	386	NOT R/M32	Reverse each bit of r/M32.
NOT	R/M64	X64	NOT R/M64	Reverse each bit of r/M64.
NOT	R/M8	8086	NOT R/M8	Reverse each bit of r/m8.
OR	AL,IMM8	8086	OR AL,IMM8	AL OR imm8.
OR	AX,IMM16	8086	OR AX,IMM16	AX OR imm16.
OR	EAX,IMM32	386	OR EAX,IMM32	EAX OR imM32.
OR	R/M16,IMM16	8086	OR R/M16,IMM16	r/m16 OR imm16.
OR	R/M16,IMM8	8086	OR R/M16,IMM8	r/m16 OR imm8 (sign-extended).
OR	R/M16,R16	8086	OR R/M16,R16	r/m16 OR r16.
OR	R/M32,IMM32	386	OR R/M32,IMM32	r/M32 OR imM32.
OR	R/M32,IMM8	386	OR R/M32,IMM8	r/M32 OR imm8 (sign-extended).
OR	R/M32,R32	386	OR R/M32,R32	r/M32 OR r32.
OR	R/M64,IMM32	X64	OR R/M64,IMM32	r/M64 OR imM32 (sign-extended).
OR	R/M64,IMM8	X64	OR R/M64,IMM8	r/M64 OR imm8 (sign-extended).
OR	R/M64,R64	X64	OR R/M64,R64	r/M64 OR r64.
OR	R/M8,IMM8	8086	OR R/M8,IMM8	r/m8 OR imm8.
OR	R/M8,R8	8086	OR R/M8,R8	r/m8 OR r8.
OR	R16,R/M16	8086	OR R16,R/M16	r16 OR r/m16.
OR	R32,R/M32	386	OR R32,R/M32	r32 OR r/M32.
OR	R64,R/M64	X64	OR R64,R/M64	r64 OR r/M64.
OR	R8,R/M8	8086	OR R8,R/M8	r8 OR r/m8.
OR	RAX,IMM32	X64	OR RAX,IMM32	RAX OR imM32 (sign-extended).
OUT	DX,AL	8086	OUT DX,AL	Output byte in AL to I/O port address in DX.
OUT	DX,AX	8086	OUT DX,AX	Output word in AX to I/O port address in DX.
OUT	DX,EAX	386	OUT DX,EAX	Output doubleword in EAX to I/O port address in DX.
OUT	IMM8,AL	8086	OUT IMM8,AL	Output byte in AL to I/O port address imm8.
OUT	IMM8,AX	8086	OUT IMM8,AX	Output word in AX to I/O port address imm8.
OUT	IMM8,EAX	386	OUT IMM8,EAX	Output doubleword in EAX to I/O port address imm8.
OUTS	DX,M16	8086	OUTS DX,M16	Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
OUTS	DX,M32	386	OUTS DX,M32	Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
OUTS	DX,M8	8086	OUTS DX,M8	Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
OUTSB		186	OUTSB	Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
OUTSD		386	OUTSD	Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
OUTSW		186	OUTSW	Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
PAUSE		8086	PAUSE	Gives hint to processor that improves performance of spin-wait loops.
POP	DS	8086	POP DS	Pop top of stack into DS; increment stack pointer.
POP	ES	8086	POP ES	Pop top of stack into ES; increment stack pointer.
POP	FS	386	POP FS	Pop top of stack into FS; increment stack pointer by 16 bits.
POP	GS	386	POP GS	Pop top of stack into GS; increment stack pointer by 16 bits.
POP	R/M16	8086	POP R/M16	Pop top of stack into m16; increment stack pointer.
POP	R/M32	386	POP R/M32	Pop top of stack into M32; increment stack pointer.
POP	R/M64	X64	POP R/M64	Pop top of stack into M64; increment stack pointer. Cannot encode 32-bit operand size.
POP	R16	8086	POP R16	Pop top of stack into r16; increment stack pointer.
POP	R32	386	POP R32	Pop top of stack into r32; increment stack pointer.
POP	R64	X64	POP R64	Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.
POP	SS	8086	POP SS	Pop top of stack into SS; increment stack pointer.

POPA		186	POPA	Pop DI, SI, BP, BX, DX, CX, and AX.
POPAD		386	POPAD	Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.
POPCNT	R16,R/M16	SSE42	POPCNT R16,R/M16	POPCNT on r/m16
POPCNT	R32,R/M32	SSE42	POPCNT R32,R/M32	POPCNT on r/M32
POPCNT	R64,R/M64	SSE42	POPCNT R64,R/M64	POPCNT on r/M64
POPF		8086	POPF	Pop top of stack into lower 16 bits of EFLAGS.
POPFD		386	POPFD	Pop top of stack into EFLAGS.
POPFQ		X64	POPFQ	Pop top of stack and zero-extend into RFLAGS.

PREFETCHNTA	M8	SSE	PREFETCHNTA M8	Move data from m8 closer to the processor using NTA hint.
PREFETCHT0	M8	SSE	PREFETCHT0 M8	Move data from m8 closer to the processor using T0 hint.
PREFETCHT1	M8	SSE	PREFETCHT1 M8	Move data from m8 closer to the processor using T1 hint.
PREFETCHT2	M8	SSE	PREFETCHT2 M8	Move data from m8 closer to the processor using T2 hint.
PSHUFW	MM,MM/M64,IMM8	MMX	PSHUFW MM1,MM2/M64,IMM8	Shuffle the words in mm2/M64 based on the encoding in imm8 and store the result in mm1.

PUSH	CS	8086	PUSH CS	Push CS.
PUSH	DS	8086	PUSH DS	Push DS.
PUSH	ES	8086	PUSH ES	Push ES.
PUSH	FS	386	PUSH FS	Push FS.
PUSH	GS	386	PUSH GS	Push GS.
PUSH	IMM16	8086	PUSH IMM16	Push imm16.
PUSH	IMM32	386	PUSH IMM32	Push imM32.
PUSH	IMM8	8086	PUSH IMM8	Push imm8.
PUSH	R/M16	8086	PUSH R/M16	Push r/m16.
PUSH	R/M32	386	PUSH R/M32	Push r/M32.
PUSH	R/M64	X64	PUSH R/M64	Push r/M64.
PUSH	R16	8086	PUSH R16	Push r16.
PUSH	R32	386	PUSH R32	Push r32.
PUSH	R64	X64	PUSH R64	Push r64.
PUSH	SS	8086	PUSH SS	Push SS.
PUSHA		186	PUSHA	Push AX, CX, DX, BX, original SP, BP, SI, and DI.
PUSHAD		386	PUSHAD	Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.
PUSHF		8086	PUSHF	Push lower 16 bits of EFLAGS.
PUSHFD		386	PUSHFD	Push EFLAGS.
RCL	R/M16,1	8086	RCL R/M16,1	Rotate 17 bits (CF, r/m16) left once.
RCL	R/M16,CL	8086	RCL R/M16,CL	Rotate 17 bits (CF, r/m16) left CL times.
RCL	R/M16,IMM8	186	RCL R/M16,IMM8	Rotate 17 bits (CF, r/m16) left imm8 times.
RCL	R/M32,1	386	RCL R/M32,1	Rotate 33 bits (CF, r/M32) left once.
RCL	R/M32,CL	386	RCL R/M32,CL	Rotate 33 bits (CF, r/M32) left CL times.
RCL	R/M32,IMM8	386	RCL R/M32,IMM8	Rotate 33 bits (CF, r/M32) left imm8 times.
RCL	R/M64,1	X64	RCL R/M64,1	Rotate 65 bits (CF, r/M64) left once. Uses a 6 bit count.
RCL	R/M64,CL	X64	RCL R/M64,CL	Rotate 65 bits (CF, r/M64) left CL times. Uses a 6 bit count.
RCL	R/M64,IMM8	X64	RCL R/M64,IMM8	Rotate 65 bits (CF, r/M64) left imm8 times. Uses a 6 bit count.
RCL	R/M8,1	8086	RCL R/M8,1	Rotate 9 bits (CF, r/m8) left once.
RCL	R/M8,CL	8086	RCL R/M8,CL	Rotate 9 bits (CF, r/m8) left CL times.
RCL	R/M8,IMM8	186	RCL R/M8,IMM8	Rotate 9 bits (CF, r/m8) left imm8 times.
RCR	R/M16,1	8086	RCR R/M16,1	Rotate 17 bits (CF, r/m16) right once.
RCR	R/M16,CL	8086	RCR R/M16,CL	Rotate 17 bits (CF, r/m16) right CL times.
RCR	R/M16,IMM8	186	RCR R/M16,IMM8	Rotate 17 bits (CF, r/m16) right imm8 times.
RCR	R/M32,1	386	RCR R/M32,1	Rotate 33 bits (CF, r/M32) right once. Uses a 6 bit count.
RCR	R/M32,CL	386	RCR R/M32,CL	Rotate 33 bits (CF, r/M32) right CL times.
RCR	R/M32,IMM8	386	RCR R/M32,IMM8	Rotate 33 bits (CF, r/M32) right imm8 times.
RCR	R/M64,1	X64	RCR R/M64,1	Rotate 65 bits (CF, r/M64) right once. Uses a 6 bit count.
RCR	R/M64,CL	X64	RCR R/M64,CL	Rotate 65 bits (CF, r/M64) right CL times. Uses a 6 bit count.
RCR	R/M64,IMM8	X64	RCR R/M64,IMM8	Rotate 65 bits (CF, r/M64) right imm8 times. Uses a 6 bit count.
RCR	R/M8,1	8086	RCR R/M8,1	Rotate 9 bits (CF, r/m8) right once.
RCR	R/M8,CL	186	RCR R/M8,CL	Rotate 9 bits (CF, r/m8) right CL times.
RCR	R/M8,IMM8	8086	RCR R/M8,IMM8	Rotate 9 bits (CF, r/m8) right imm8 times.

RDMSR		PENT	RDMSR	Read MSR specified by ECX into EDX:EAX.
RDPKRU		X64	RDPKRU	Reads PKRU (Protection Key Rights for User Pages) into EAX.
RDPMC		P6	RDPMC	Read performance-monitoring counter specified by ECX into EDX:EAX.
RDTSC		PENT	RDTSC	Read time-stamp counter into EDX:EAX.
RDTSCP		X64	RDTSCP	Read 64-bit time-stamp counter and IA32_TSC_AUX value into EDX:EAX and ECX.

RET		8086	RET	Near return to calling procedure.
RET	IMM16	8086	RET IMM16	Near return to calling procedure and pop imm16 bytes from stack.
ROL	R/M8,1	8086	ROL R/M8,1	Rotate 8 bits r/m8 left once.
ROL	R/M8,CL	186	ROL R/M8,CL	Rotate 8 bits r/m8 left CL times.
ROL	R/M8,IMM8	8086	ROL R/M8,IMM8	Rotate 8 bits r/m8 left imm8 times.
RSM		PENT	RSM	Resume operation of interrupted program.
SAHF		8086	SAHF	Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register.

SAL	R/M8,1	8086	SAL R/M8,1	Multiply r/m8 by 2, once.
SAL	R/M8,CL	186	SAL R/M8,CL	Multiply r/m8 by 2, CL times.
SAL	R/M8,IMM8	8086	SAL R/M8,IMM8	Multiply r/m8 by 2, imm8 times.
SAL	R/M16,1	8086	SAL R/M16,1	Multiply r/m16 by 2, once.
SAL	R/M16,CL	186	SAL R/M16,CL	Multiply r/m16 by 2, CL times.
SAL	R/M16,IMM8	8086	SAL R/M16,IMM8	Multiply r/m16 by 2, imm8 times.
SAL	R/M32,1	386	SAL R/M32,1	Multiply r/M32 by 2, once.
SAL	R/M32,CL	386	SAL R/M32,CL	Multiply r/M32 by 2, CL times.
SAL	R/M32,IMM8	386	SAL R/M32,IMM8	Multiply r/M32 by 2, imm8 times.
SAL	R/M64,1	X64	SAL R/M64,1	Multiply r/M64 by 2, once.
SAL	R/M64,CL	X64	SAL R/M64,CL	Multiply r/M64 by 2, CL times.
SAL	R/M64,IMM8	X64	SAL R/M64,IMM8	Multiply r/M64 by 2, imm8 times.

SAR	R/M8,1	8086	SAR R/M8,1	Signed divide r/m8 by 2, once.
SAR	R/M8,CL	186	SAR R/M8,CL	Signed divide r/m8 by 2, CL times.
SAR	R/M8,IMM8	8086	SAR R/M8,IMM8	Signed divide r/m8 by 2, imm8 time.
SAR	R/M16,1	8086	SAR R/M16,1	Signed divide r/m16 by 2, once.
SAR	R/M16,CL	186	SAR R/M16,CL	Signed divide r/m16 by 2, CL times.
SAR	R/M16,IMM8	8086	SAR R/M16,IMM8	Signed divide r/m16 by 2, imm8 times.
SAR	R/M32,1	386	SAR R/M32,1	Signed divide r/M32 by 2, once.
SAR	R/M32,CL	386	SAR R/M32,CL	Signed divide r/M32 by 2, CL times.
SAR	R/M32,IMM8	386	SAR R/M32,IMM8	Signed divide r/M32 by 2, imm8 times.
SAR	R/M64,1	X64	SAR R/M64,1	Signed divide r/M64 by 2, once.
SAR	R/M64,CL	X64	SAR R/M64,CL	Signed divide r/M64 by 2, CL times.
SAR	R/M64,IMM8	X64	SAR R/M64,IMM8	Signed divide r/M64 by 2, imm8 times

SBB	AL,IMM8	8086	SBB AL,IMM8	Subtract with borrow imm8 from AL.
SBB	AX,IMM16	8086	SBB AX,IMM16	Subtract with borrow imm16 from AX.
SBB	EAX,IMM32	386	SBB EAX,IMM32	Subtract with borrow imM32 from EAX.
SBB	R/M16,IMM16	8086	SBB R/M16,IMM16	Subtract with borrow imm16 from r/m16.
SBB	R/M16,IMM8	8086	SBB R/M16,IMM8	Subtract with borrow sign-extended imm8 from r/m16.
SBB	R/M16,R16	8086	SBB R/M16,R16	Subtract with borrow r16 from r/m16.
SBB	R/M32,IMM32	8086	SBB R/M32,IMM32	Subtract with borrow imM32 from r/M32.
SBB	R/M32,IMM8	386	SBB R/M32,IMM8	Subtract with borrow sign-extended imm8 from r/M32.
SBB	R/M32,R32	386	SBB R/M32,R32	Subtract with borrow r32 from r/M32.
SBB	R/M64,IMM32	X64	SBB R/M64,IMM32	Subtract with borrow sign-extended imM32 to 64-bits from r/M64.
SBB	R/M64,IMM8	X64	SBB R/M64,IMM8	Subtract with borrow sign-extended imm8 from r/M64.
SBB	R/M64,R64	X64	SBB R/M64,R64	Subtract with borrow r64 from r/M64.
SBB	R/M8,IMM8	8086	SBB R/M8,IMM8	Subtract with borrow imm8 from r/m8.
SBB	R/M8,R8	8086	SBB R/M8,R8	Subtract with borrow r8 from r/m8.
SBB	R16,R/M16	8086	SBB R16,R/M16	Subtract with borrow r/m16 from r16.
SBB	R32,R/M32	386	SBB R32,R/M32	Subtract with borrow r/M32 from r32.
SBB	R64,R/M64	X64	SBB R64,R/M64	Subtract with borrow r/M64 from r64.
SBB	R8,R/M8	8086	SBB R8,R/M8	Subtract with borrow r/m8 from r8.
SBB	RAX,IMM32	386	SBB RAX,IMM32	Subtract with borrow sign-extended imm.32 to 64-bits from RAX.

SCAS	M8	8086	SCAS M8	Compare AL with byte at ES:(E)DI or RDI, then set status flags.
SCAS	M16	8086	SCAS M16	Compare AX with word at ES:(E)DI or RDI, then set status flags.
SCAS	M32	386	SCAS M32	Compare EAX with doubleword at ES(E)DI or RDI then set status flags.
SCAS	M64	X64	SCAS M64	Compare RAX with quadword at RDI or EDI then set status flags.

SCASB		8086	SCASB	Compare AL with byte at ES:(E)DI or RDI then set status flags.
SCASD		386	SCASD	Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.
SCASW		8086	SCASW	Compare AX with word at ES:(E)DI or RDI then set status flags.
SFENCE		X64	SFENCE	Serializes store operations.
SGDT	MEM	286	SGDT MEM	Store Global Descriptor Table Register (GDTR) to mem.

SHL	R/M8,1	8086	SHL R/M8,1	Multiply r/m8 by 2, once.
SHL	R/M8,CL	186	SHL R/M8,CL	Multiply r/m8 by 2, CL times.
SHL	R/M8,IMM8	8086	SHL R/M8,IMM8	Multiply r/m8 by 2, imm8 times.
SHL	R/M16,1	8086	SHL R/M16,1	Multiply r/m16 by 2, once.
SHL	R/M16,CL	186	SHL R/M16,CL	Multiply r/m16 by 2, CL times.
SHL	R/M16,IMM8	8086	SHL R/M16,IMM8	Multiply r/m16 by 2, imm8 times.
SHL	R/M32,1	386	SHL R/M32,1	Multiply r/M32 by 2, once.
SHL	R/M32,CL	386	SHL R/M32,CL	Multiply r/M32 by 2, CL times.
SHL	R/M32,IMM8	386	SHL R/M32,IMM8	Multiply r/M32 by 2, imm8 times.
SHL	R/M64,1	X64	SHL R/M64,1	Multiply r/M64 by 2, once.
SHL	R/M64,CL	X64	SHL R/M64,CL	Multiply r/M64 by 2, CL times.
SHL	R/M64,IMM8	X64	SHL R/M64,IMM8	Multiply r/M64 by 2, imm8 times.

SHLD	R/M16,R16,CL	386	SHLD R/M16,R16,CL	Shift r/m16 to left CL places while shifting bits from r16 in from the right.
SHLD	R/M16,R16,IMM8	386	SHLD R/M16,R16,IMM8	Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
SHLD	R/M32,R32,CL	386	SHLD R/M32,R32,CL	Shift r/M32 to left CL places while shifting bits from r32 in from the right.
SHLD	R/M32,R32,IMM8	386	SHLD R/M32,R32,IMM8	Shift r/M32 to left imm8 places while shifting bits from r32 in from the right.
SHLD	R/M64,R64,CL	X64	SHLD R/M64,R64,CL	Shift r/M64 to left CL places while shifting bits from r64 in from the right.
SHLD	R/M64,R64,IMM8	X64	SHLD R/M64,R64,IMM8	Shift r/M64 to left imm8 places while shifting bits from r64 in from the right.

SHRD	R/M16,R16,CL	386	SHRD R/M16,R16,CL	Shift r/m16 to right CL places while shifting bits from r16 in from the left.
SHRD	R/M16,R16,IMM8	386	SHRD R/M16,R16,IMM8	Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
SHRD	R/M32,R32,CL	386	SHRD R/M32,R32,CL	Shift r/M32 to right CL places while shifting bits from r32 in from the left.
SHRD	R/M32,R32,IMM8	386	SHRD R/M32,R32,IMM8	Shift r/M32 to right imm8 places while shifting bits from r32 in from the left.
SHRD	R/M64,R64,CL	X64	SHRD R/M64,R64,CL	Shift r/M64 to right CL places while shifting bits from r64 in from the left.
SHRD	R/M64,R64,IMM8	X64	SHRD R/M64,R64,IMM8	Shift r/M64 to right imm8 places while shifting bits from r64 in from the left.

SIDT	MEM	286	SIDT MEM	Store Interrupt Descriptor Table Register (IDTR) to mem.
SLDT	R/M16	286	SLDT R/M16	Stores segment selector from Local Descriptor Table Register (LDTR) in r/m16.
SLDT	R64/M16	X64	SLDT R64/M16	Stores segment selector from Local Descriptor Table Register (LDTR) in r64/m16.

SMSW	R/M16	286	SMSW R/M16	Store machine status word to r/m16.
SMSW	R32/M16	386	SMSW R32/M16	Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.
SMSW	R64/M16	X64	SMSW R64/M16	Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined.

STAC		486	STAC	Set the Alignment Check (AC) flag in the EFLAGS register.
STC		8086	STC	Set CF flag.
STD		8086	STD	Set DF flag.
STI		8086	STI	Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.

STOS	M8	8086	STOS M8	For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
STOS	M16	8086	STOS M16	For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
STOS	M32	386	STOS M32	For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
STOS	M64	X64	STOS M64	Store RAX at address RDI or EDI.

STOSB		8086	STOSB	For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
STOSD		386	STOSD	For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
STOSQ		X64	STOSQ	Store RAX at address RDI or EDI.
STOSW		8086	STOSW	For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.

STR	R/M16	286	STR R/M16	Stores segment selector from Task Register (TR) in r/m16.
STR	R32	386	STR R32	Stores segment selector from Task Register (TR) in r32.
STR	R64	X64	STR R64	Stores segment selector from Task Register (TR) in r64.

SUB	AL,IMM8	8086	SUB AL,IMM8	Subtract imm8 from AL.
SUB	AX,IMM16	8086	SUB AX,IMM16	Subtract imm16 from AX.
SUB	EAX,IMM32	386	SUB EAX,IMM32	Subtract imM32 from EAX.
SUB	R/M16,IMM16	8086	SUB R/M16,IMM16	Subtract imm16 from r/m16.
SUB	R/M16,IMM8	8086	SUB R/M16,IMM8	Subtract sign-extended imm8 from r/m16.
SUB	R/M16,R16	8086	SUB R/M16,R16	Subtract r16 from r/m16.
SUB	R/M32,IMM32	386	SUB R/M32,IMM32	Subtract imM32 from r/M32.
SUB	R/M32,IMM8	386	SUB R/M32,IMM8	Subtract sign-extended imm8 from r/M32.
SUB	R/M32,R32	386	SUB R/M32,R32	Subtract r32 from r/M32.
SUB	R/M64,IMM32	X64	SUB R/M64,IMM32	Subtract imM32 sign-extended to 64-bits from r/M64.
SUB	R/M64,IMM8	X64	SUB R/M64,IMM8	Subtract sign-extended imm8 from r/M64.
SUB	R/M64,R64	X64	SUB R/M64,R64	Subtract r64 from r/M64.
SUB	R/M8,IMM8	8086	SUB R/M8,IMM8	Subtract imm8 from r/m8.
SUB	R/M8,R8	8086	SUB R/M8,R8	Subtract r8 from r/m8.
SUB	R16,R/M16	8086	SUB R16,R/M16	Subtract r/m16 from r16.
SUB	R32,R/M32	386	SUB R32,R/M32	Subtract r/M32 from r32.
SUB	R64,R/M64	X64	SUB R64,R/M64	Subtract r/M64 from r64.
SUB	R8,R/M8	8086	SUB R8,R/M8	Subtract r/m8 from r8.
SUB	RAX,IMM32	386	SUB RAX,IMM32	Subtract imM32 sign-extended to 64-bits from RAX.

SWAPGS		X64	SWAPGS	Exchanges the current GS base register value with the value contained in MSR address C0000102H.
SYSCALL		P6	SYSCALL	Fast call to privilege level 0 system procedures.
SYSENTER		P6	SYSENTER	Fast call to privilege level 0 system procedures.
SYSEXIT		P6	SYSEXIT	Fast return to privilege level 3 user code.
SYSRET		P6	SYSRET	Return to compatibility mode from fast system call

TEST	AL,IMM8	8086	TEST AL,IMM8	AND imm8 with AL; set SF, ZF, PF according to result.
TEST	AX,IMM16	8086	TEST AX,IMM16	AND imm16 with AX; set SF, ZF, PF according to result.
TEST	EAX,IMM32	386	TEST EAX,IMM32	AND imM32 with EAX; set SF, ZF, PF according to result.
TEST	R/M16,IMM16	8086	TEST R/M16,IMM16	AND imm16 with r/m16; set SF, ZF, PF according to result.
TEST	R/M16,R16	8086	TEST R/M16,R16	AND r16 with r/m16; set SF, ZF, PF according to result.
TEST	R/M32,IMM32	386	TEST R/M32,IMM32	AND imM32 with r/M32; set SF, ZF, PF according to result.
TEST	R/M32,R32	386	TEST R/M32,R32	AND r32 with r/M32; set SF, ZF, PF according to result.
TEST	R/M64,IMM32	X64	TEST R/M64,IMM32	AND imM32 sign-extended to 64-bits with r/M64; set SF, ZF, PF according to result.
TEST	R/M64,R64	X64	TEST R/M64,R64	AND r64 with r/M64; set SF, ZF, PF according to result.
TEST	R/M8,IMM8	8086	TEST R/M8,IMM8	AND imm8 with r/m8; set SF, ZF, PF according to result.
TEST	R/M8,R8	8086	TEST R/M8,R8	AND r8 with r/m8; set SF, ZF, PF according to result.
TEST	RAX,IMM32	386	TEST RAX,IMM32	AND imM32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.

VERR	R/M16	286	VERR R/M16	Set ZF=1 if segment specified with r/m16 can be read.
VERW	R/M16	286	VERW R/M16	Set ZF=1 if segment specified with r/m16 can be written.

WAIT		8086	WAIT	Check pending unmasked floating-point exceptions.
FWAIT		8086	FWAIT	Check pending unmasked floating-point exceptions.

WBINVD		486	WBINVD	Write back and flush Internal caches; initiate writing-back and flushing of external caches.
WRMSR		PENT	WRMSR	Write the value in EDX:EAX to Model Specific Register (MSR) specified by ECX.
WRPKRU		X64	WRPKRU	Writes EAX into PKRU (Protection Key Rights for User Pages).

XADD	R/M16,R16	486	XADD R/M16,R16	Exchange r16 and r/m16; load sum into r/m16.
XADD	R/M32,R32	486	XADD R/M32,R32	Exchange r32 and r/M32; load sum into r/M32.
XADD	R/M64,R64	X64	XADD R/M64,R64	Exchange r64 and r/M64; load sum into r/M64.
XADD	R/M8,R8	486	XADD R/M8,R8	Exchange r8 and r/m8; load sum into r/m8.

XCHG	AX,R16	8086	XCHG AX,R16	Exchange r16 with AX.
XCHG	EAX,R32	386	XCHG EAX,R32	Exchange r32 with EAX.
XCHG	R/M16,R16	8086	XCHG R/M16,R16	Exchange r16 with word from r/m16.
XCHG	R/M32,R32	386	XCHG R/M32,R32	Exchange r32 with doubleword from r/M32.
XCHG	R/M64,R64	X64	XCHG R/M64,R64	Exchange r64 with quadword from r/M64.
XCHG	R/M8,R8	8086	XCHG R/M8,R8	Exchange r8 (byte register) with byte from r/m8.
XCHG	R16,AX	8086	XCHG R16,AX	Exchange AX with r16.
XCHG	R16,R/M16	8086	XCHG R16,R/M16	Exchange word from r/m16 with r16.
XCHG	R32,EAX	386	XCHG R32,EAX	Exchange EAX with r32.
XCHG	R32,R/M32	386	XCHG R32,R/M32	Exchange doubleword from r/M32 with r32.
XCHG	R64,R/M64	X64	XCHG R64,R/M64	Exchange quadword from r/M64 with r64.
XCHG	R64,RAX	X64	XCHG R64,RAX	Exchange RAX with r64.
XCHG	R8,R/M8	8086	XCHG R8,R/M8	Exchange byte from r/m8 with r8 (byte register).
XCHG	RAX,R64	X64	XCHG RAX,R64	Exchange r64 with RAX.

XLAT	M8	8086	XLAT M8	Set AL to memory byte DS:[(E)BX + unsigned AL].
XLATB		8086	XLATB	Set AL to memory byte DS:[(E)BX + unsigned AL].

XOR	AL,IMM8	8086	XOR AL,IMM8	AL XOR imm8.
XOR	AX,IMM16	8086	XOR AX,IMM16	AX XOR imm16.
XOR	EAX,IMM32	386	XOR EAX,IMM32	EAX XOR imM32.
XOR	R/M16,IMM16	8086	XOR R/M16,IMM16	r/m16 XOR imm16.
XOR	R/M16,IMM8	8086	XOR R/M16,IMM8	r/m16 XOR imm8 (sign-extended).
XOR	R/M16,R16	8086	XOR R/M16,R16	r/m16 XOR r16.
XOR	R/M32,IMM32	386	XOR R/M32,IMM32	r/M32 XOR imM32.
XOR	R/M32,IMM8	386	XOR R/M32,IMM8	r/M32 XOR imm8 (sign-extended).
XOR	R/M32,R32	386	XOR R/M32,R32	r/M32 XOR r32.
XOR	R/M64,IMM32	X64	XOR R/M64,IMM32	r/M64 XOR imM32 (sign-extended).
XOR	R/M64,IMM8	X64	XOR R/M64,IMM8	r/M64 XOR imm8 (sign-extended).
XOR	R/M64,R64	X64	XOR R/M64,R64	r/M64 XOR r64.
XOR	R/M8,IMM8	8086	XOR R/M8,IMM8	r/m8 XOR imm8.
XOR	R/M8,R8	8086	XOR R/M8,R8	r/m8 XOR r8.
XOR	R16,R/M16	8086	XOR R16,R/M16	r16 XOR r/m16.
XOR	R32,R/M32	386	XOR R32,R/M32	r32 XOR r/M32.
XOR	R64,R/M64	X64	XOR R64,R/M64	r64 XOR r/M64.
XOR	R8,R/M8	8086	XOR R8,R/M8	r8 XOR r/m8.
XOR	RAX,IMM32	386	XOR RAX,IMM32	RAX XOR imM32 (sign-extended).

XGETBV		SSE42	XGETBV	Reads an XCR specified by ECX into EDX:EAX.
XRSTOR	MEM	SSE42	XRSTOR MEM	Restore state components specified by EDX:EAX from mem.
XRSTORS	MEM	SSE42	XRSTORS MEM	Restore state components specified by EDX:EAX from mem.
XSAVE	MEM	SSE42	XSAVE MEM	Save state components specified by EDX:EAX to mem.
XSAVEC	MEM	SSE42	XSAVEC MEM	Save state components specified by EDX:EAX to mem with compaction.
XSAVES	MEM	SSE42	XSAVES MEM	Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.
XSETBV		SSE42	XSETBV	Write the value in EDX:EAX to the XCR specified by ECX.